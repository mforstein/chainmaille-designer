// src/App.tsx
// ============================================================================
// Chainmaille Designer • European 4-in-1
// A complete interactive design tool for chainmail sheets.
// ============================================================================

import React, { useEffect, useMemo, useRef, useState } from "react";
import ImageOverlayPanel from "./ImageOverlayPanel";
import PrintPreviewOverlay from "./components/PrintPreviewOverlay";
import Paywall from "./components/Paywall";
import useUnlocked from "./hooks/useUnlocked";
import EulaDialog from "./components/EulaDialog";

// ============================================================================
// TYPES
// ============================================================================

/**
 * Represents one individual ring in the sheet.
 */
interface Ring {
  row: number;
  col: number;
  x: number;
  y: number;
  radius: number;
  color?: string;
  previewColor?: string;
  supplier?: "cmj" | "trl" | "mdz";
}

type ColorMode = "solid" | "checker";
type Unit = "mm" | "in";
type SupplierId = "cmj" | "trl" | "mdz";

interface Params {
  rows: number;
  cols: number;
  innerDiameter: number;
  wireDiameter: number;
  overlapX: number;
  overlapY: number;
  colorMode: ColorMode;
  ringColor: string;
  altColor: string;
  bgColor: string;
  supplier: SupplierId;
  ringSpec: string;
  unit: Unit;
}

// ============================================================================
// SUPPLIER DATA
// ============================================================================

const SUPPLIERS: { id: SupplierId; name: string; url: string }[] = [
  { id: "cmj", name: "Chainmail Joe", url: "https://chainmailjoe.com/" },
  { id: "trl", name: "The Ring Lord", url: "https://theringlord.com/" },
  { id: "mdz", name: "MetalDesignz", url: "https://www.metaldesignz.com/jump-rings/" },
];

const RING_SPECS = [
  { label: '1/4" 16swg AR~4.0', inner: 6.35, wire: 1.6 },
  { label: '5/16" 16swg AR~5.0', inner: 7.94, wire: 1.6 },
  { label: '3/8" 16swg AR~6.2', inner: 9.53, wire: 1.6 },
  { label: '1/4" 18swg AR~4.4', inner: 6.35, wire: 1.2 },
  { label: '5/16" 18swg AR~6.1', inner: 7.94, wire: 1.2 },
];

const DEFAULTS: Params = {
  rows: 5,
  cols: 5,
  innerDiameter: 6.35,
  wireDiameter: 1.6,
  overlapX: 0.30,
  overlapY: 0.15,
  colorMode: "solid",
  ringColor: "#000000",
  altColor: "#808080",
  bgColor: "#ffffff",
  supplier: "cmj",
  ringSpec: '1/4" 16swg AR~4.0',
  unit: "mm",
};

const FIXED_PACK_SIZE = 1800;

// ============================================================================
// SUPPLIER COLORS
// ============================================================================

const SUPPLIER_COLORS: Record<
  SupplierId,
  { supplier: SupplierId; name: string; hex: string }[]
> = {
  cmj: [
    { supplier: "cmj", name: "Bright Aluminum", hex: "#C0C0C0" },
    { supplier: "cmj", name: "Black", hex: "#000000" },
    { supplier: "cmj", name: "Gold", hex: "#FFD700" },
    { supplier: "cmj", name: "Silver", hex: "#B8B8B8" },
    { supplier: "cmj", name: "Red", hex: "#FF0000" },
    { supplier: "cmj", name: "Blue", hex: "#0A58FF" },
    { supplier: "cmj", name: "Kelly Green", hex: "#4CBB17" },
    { supplier: "cmj", name: "OD Green", hex: "#556B2F" },
    { supplier: "cmj", name: "Violet", hex: "#8F00FF" },
    { supplier: "cmj", name: "Cosmic Pink", hex: "#FF1493" },
    { supplier: "cmj", name: "Stormy Gray", hex: "#708090" },
    { supplier: "cmj", name: "Orange", hex: "#FF8C00" },
    { supplier: "cmj", name: "Turquoise", hex: "#40E0D0" },
    { supplier: "cmj", name: "Teal", hex: "#008080" },
    { supplier: "cmj", name: "Bronze", hex: "#CD7F32" },
    { supplier: "cmj", name: "Copper", hex: "#B87333" },
    { supplier: "cmj", name: "Champagne", hex: "#E6C79C" },
    { supplier: "cmj", name: "Rose Gold", hex: "#B76E79" },
    { supplier: "cmj", name: "Lime", hex: "#BFFF00" },
    { supplier: "cmj", name: "Yellow", hex: "#FFFF00" },
    { supplier: "cmj", name: "Magenta", hex: "#FF00FF" },
    { supplier: "cmj", name: "Purple", hex: "#800080" },
    { supplier: "cmj", name: "Navy", hex: "#001F54" },
    { supplier: "cmj", name: "Sky Blue", hex: "#87CEEB" },
    { supplier: "cmj", name: "Aqua", hex: "#00FFFF" },
    { supplier: "cmj", name: "Mint", hex: "#98FF98" },
    { supplier: "cmj", name: "Dark Red", hex: "#8B0000" },
    { supplier: "cmj", name: "Maroon", hex: "#800000" },
    { supplier: "cmj", name: "Charcoal", hex: "#36454F" },
    { supplier: "cmj", name: "Gunmetal", hex: "#2A3439" },
  ],
  trl: [
    { supplier: "trl", name: "Black Ice", hex: "#1D1F2B" },
    { supplier: "trl", name: "Frost", hex: "#D4D4D4" },
    { supplier: "trl", name: "Dark Rose", hex: "#A05056" },
    { supplier: "trl", name: "Lime", hex: "#BFFF00" },
    { supplier: "trl", name: "Orange", hex: "#FFA500" },
    { supplier: "trl", name: "Yellow", hex: "#FFFF00" },
    { supplier: "trl", name: "Green", hex: "#008000" },
    { supplier: "trl", name: "Purple", hex: "#800080" },
    { supplier: "trl", name: "Blue", hex: "#0000FF" },
    { supplier: "trl", name: "Silver", hex: "#C0C0C0" },
    { supplier: "trl", name: "Copper", hex: "#B87333" },
    { supplier: "trl", name: "Bronze", hex: "#CD7F32" },
    { supplier: "trl", name: "Teal", hex: "#008080" },
    { supplier: "trl", name: "Turquoise", hex: "#40E0D0" },
    { supplier: "trl", name: "Pink", hex: "#FF69B4" },
    { supplier: "trl", name: "Royal Blue", hex: "#4169E1" },
    { supplier: "trl", name: "Sea Green", hex: "#2E8B57" },
    { supplier: "trl", name: "Graphite", hex: "#3B3B3B" },
    { supplier: "trl", name: "Steel", hex: "#7A7A7A" },
    { supplier: "trl", name: "Champagne", hex: "#E6C79C" },
  ],
  mdz: [
    { supplier: "mdz", name: "Aluminum", hex: "#C0C0C0" },
    { supplier: "mdz", name: "Black", hex: "#000000" },
    { supplier: "mdz", name: "Gold", hex: "#FFD700" },
    { supplier: "mdz", name: "Silver", hex: "#B8B8B8" },
  ],
};

/** Resolve supplier color name from hex */
function supplierColorName(s: SupplierId, hex: string): string {
  const entry = SUPPLIER_COLORS[s].find(
    (c) => c.hex.toUpperCase() === hex.toUpperCase()
  );
  return entry?.name ?? hex;
}

// ============================================================================
// MATH HELPERS — Corrected for true European 4-in-1 weave geometry
// ============================================================================

const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));

/**
 * Defines the horizontal and vertical spacing between ring centers.
 * The horizontal pitch is half the ring’s diameter — rings overlap 50%.
 * The vertical pitch is approximately 0.433 × diameter (√3/2 × radius),
 * giving the proper diagonal chainmail weave structure.
 */
function pitches(p: Params) {
  // 0.5 → rings overlap halfway horizontally
  const pitchX = p.innerDiameter * 0.5;

  // √3/2 ≈ 0.866 → times radius gives correct hexagonal alignment
  const pitchY = (p.innerDiameter + p.wireDiameter) * 0.5;

  return { pitchX, pitchY };
}

/**
 * Compute world (canvas) size of the grid in physical units
 */
function worldSize(p: Params) {
  const { pitchX, pitchY } = pitches(p);
  const width = (p.cols - 1) * pitchX + p.innerDiameter;
  const height = (p.rows - 1) * pitchY + p.innerDiameter;
  return { width, height };
}

/**
 * Generates the array of ring positions in a staggered pattern.
 * Odd rows are offset by half a pitch, creating the interlaced hex grid.
 */
function generateRings(p: Params): Ring[] {
  const { pitchX, pitchY } = pitches(p);
  const r = p.innerDiameter / 2;
  const rings: Ring[] = [];

  for (let row = 0; row < p.rows; row++) {
    for (let col = 0; col < p.cols; col++) {
      // stagger every other row by half-pitch
      const x = col * pitchX + (row % 2) * (pitchX / 2);
      const y = row * pitchY;
      rings.push({ row, col, x, y, radius: r });
    }
  }

  return rings;
}

function syncRings(p: Params, prev: Ring[]): Ring[] {
  const base = generateRings(p);
  if (!prev.length) return base;
  const colorMap = new Map<string, { color?: string; supplier?: SupplierId }>();
  for (const r of prev) {
    colorMap.set(`${r.row}:${r.col}`, {
      color: r.color,
      supplier: r.supplier,
    });
  }
  return base.map((r) => {
    const v = colorMap.get(`${r.row}:${r.col}`);
    return v ? { ...r, color: v.color, supplier: v.supplier } : r;
  });
}

// ============================================================================
// IMAGE HELPERS
// ============================================================================

async function rasterizeImageToRGBA(
  file: File,
  outW: number,
  outH: number,
  scaleFactor: number,
  offset: { x: number; y: number },
  rotation: number
): Promise<ImageData> {
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.src = url;
  await img.decode();

  const canvas = document.createElement("canvas");
  canvas.width = outW;
  canvas.height = outH;

  const ctx = canvas.getContext("2d")!;
  ctx.clearRect(0, 0, outW, outH);
  ctx.save();
  ctx.translate(outW / 2 + offset.x, outH / 2 + offset.y);
  ctx.rotate((rotation * Math.PI) / 180);
  const fitScale = Math.min(outW / img.width, outH / img.height) * scaleFactor;
  ctx.scale(fitScale, fitScale);
  ctx.drawImage(img, -img.width / 2, -img.height / 2);
  ctx.restore();

  const data = ctx.getImageData(0, 0, outW, outH);
  URL.revokeObjectURL(url);
  return data;
}

function hexToRgb(hex: string) {
  const s = hex.replace("#", "");
  const n = parseInt(s, 16);
  return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
}

function rgbDist2(a: { r: number; g: number; b: number }, b: { r: number; g: number; b: number }) {
  const dr = a.r - b.r;
  const dg = a.g - b.g;
  const db = a.b - b.b;
  return dr * dr + dg * dg + db * db;
}

// ============================================================================
// APP COMPONENT — START
// ============================================================================

export default function App() {
  const { unlocked } = useUnlocked();

  // --------------------------------------------------------------------------
  // ABOUT + PRINT PREVIEW MODALS
  // --------------------------------------------------------------------------
  const [showAbout, setShowAbout] = useState(false);
  const [showPrintPreview, setShowPrintPreview] = useState(false);
  const [scrollLocked, setScrollLocked] = useState(false);

  // --------------------------------------------------------------------------
  // VIEW SIZE
  // --------------------------------------------------------------------------
  const [viewSize, setViewSize] = useState(200);

  // --------------------------------------------------------------------------
  // PARAMETER STATE
  // --------------------------------------------------------------------------
  const [params, setParams] = useState<Params>(DEFAULTS);
  const [rings, setRings] = useState<Ring[]>([]);
  const [selectedRing, setSelectedRing] = useState<Ring | null>(null);

  useEffect(() => {
    if (localStorage.getItem("reset") === "true") {
      setParams({ ...DEFAULTS, rows: 5, cols: 5 }); // force back to 5×5
      localStorage.removeItem("reset"); // clear so it only runs once
    }
  }, []);
  // --------------------------------------------------------------------------
  // PRINT PREVIEW STATE
  // --------------------------------------------------------------------------
  const [pagesX, setPagesX] = useState(1);
  const [pagesY, setPagesY] = useState(1);
  const [printPages, setPrintPages] = useState<string[]>([]);

  // --------------------------------------------------------------------------
  // TOOL STATES
  // --------------------------------------------------------------------------
  const [paintMode, setPaintMode] = useState(false);
  const [eraserMode, setEraserMode] = useState(false);
  const [isPainting, setIsPainting] = useState(false);
  const [currentBrushColor, setCurrentBrushColor] = useState("#ffffff");
  const [panZoomEnabled, setPanZoomEnabled] = useState(true);
  const [touchPanZoomEnabled, setTouchPanZoomEnabled] = useState(true);

  // --------------------------------------------------------------------------
  // VIEWPORT STATES
  // --------------------------------------------------------------------------
  const [scale, setScale] = useState(1);
  const [offset, setOffset] = useState({ x: 40, y: 40 });
  const [isPanning, setIsPanning] = useState(false);
  const panStart = useRef<{ x: number; y: number } | null>(null);

  // --------------------------------------------------------------------------
  // REFS
  // --------------------------------------------------------------------------
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const wrapRef = useRef<HTMLDivElement>(null);

  // --------------------------------------------------------------------------
  // IMAGE MAPPING STATES
  // --------------------------------------------------------------------------
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [imageScale, setImageScale] = useState(1);
  const [paletteSource, setPaletteSource] = useState<"current" | "cmj" | "trl" | "mdz" | "all">("all");
  const [previewOffset, setPreviewOffset] = useState({ x: 0, y: 0 });
  const [previewRotation, setPreviewRotation] = useState(0);
  // Image preview cache — prevents flickering and ensures image is loaded before drawing
  const [previewImage, setPreviewImage] = useState<HTMLImageElement | null>(null);

  useEffect(() => {
    if (!imageFile) {
      setPreviewImage(null);
      return;
    }

    const img = new Image();
    img.src = URL.createObjectURL(imageFile);
    img.onload = () => {
      setPreviewImage(img);
      URL.revokeObjectURL(img.src);
    };
  }, [imageFile]);
  
  // --------------------------------------------------------------------------
  // HIGHLIGHT STATES
  // --------------------------------------------------------------------------
  const [highlightSupplier, setHighlightSupplier] = useState<SupplierId | "">("");
  const [highlightHex, setHighlightHex] = useState<string>("");

  // --------------------------------------------------------------------------
  // UNDO/REDO STACKS
  // --------------------------------------------------------------------------
  const undoStack = useRef<
    { colors: (string | undefined)[]; suppliers: (SupplierId | undefined)[] }[]
  >([]);
  const redoStack = useRef<
    { colors: (string | undefined)[]; suppliers: (SupplierId | undefined)[] }[]
  >([]);

  // --------------------------------------------------------------------------
  // RING GENERATION + SYNC
  // --------------------------------------------------------------------------
  useEffect(() => {
    setRings((prev) => syncRings(params, prev));
  }, [
    params.rows,
    params.cols,
    params.innerDiameter,
    params.wireDiameter,
    params.overlapX,
    params.overlapY,
  ]);

  // --------------------------------------------------------------------------
  // CANVAS RENDERING
  // --------------------------------------------------------------------------
  const { worldW, worldH, pad } = useMemo(() => {
    const { width, height } = worldSize(params);
    const pad = Math.max(40, params.innerDiameter * 2);
    return { worldW: width, worldH: height, pad };
  }, [params]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const dpr = window.devicePixelRatio || 1;

    // Use the square viewSize for both width & height
    canvas.width = viewSize * dpr;
    canvas.height = viewSize * dpr;

    // CSS display size (not stretched)
    canvas.style.width = `${viewSize}px`;
    canvas.style.height = `${viewSize}px`;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    // Reset transform so 1 unit = 1 CSS pixel
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw(ctx, viewSize, viewSize);
  }, [
    params,
    rings,
    selectedRing,
    scale,
    offset,
    worldW,
    worldH,
    pad,
    highlightHex,
    highlightSupplier,
    viewSize,
    previewImage,
  ]);

  // ✅ Auto-center the chainmail inlay after first mount or view size change
  useEffect(() => {
    // Center only once — don’t override manual panning
    if (offset.x === 40 && offset.y === 40) {
      setOffset({ x: 0, y: 0 });
    }
  }, [viewSize, params.rows, params.cols, params.innerDiameter, params.wireDiameter]);

  // --------------------------------------------------------------------------
  // HISTORY (UNDO/REDO)
  // --------------------------------------------------------------------------
  function snapshot() {
    const colors = rings.map((r) => r.color);
    const suppliers = rings.map((r) => r.supplier);
    undoStack.current.push({ colors, suppliers });
    if (undoStack.current.length > 100) undoStack.current.shift();
    redoStack.current.length = 0;
  }

  function undo() {
    if (!undoStack.current.length) return;
    const last = undoStack.current.pop()!;
    const cur = {
      colors: rings.map((r) => r.color),
      suppliers: rings.map((r) => r.supplier),
    };
    redoStack.current.push(cur);
    setRings((prev) =>
      prev.map((r, i) => ({
        ...r,
        color: last.colors[i],
        supplier: last.suppliers[i],
      }))
    );
  }

  function redo() {
    if (!redoStack.current.length) return;
    const next = redoStack.current.pop()!;
    const cur = {
      colors: rings.map((r) => r.color),
      suppliers: rings.map((r) => r.supplier),
    };
    undoStack.current.push(cur);
    setRings((prev) =>
      prev.map((r, i) => ({
        ...r,
        color: next.colors[i],
        supplier: next.suppliers[i],
      }))
    );
  }
  
  // --------------------------------------------------------------------------
  // COLOR LOGIC
  // --------------------------------------------------------------------------
function ringColorFallback(r: Ring): string {
  if (r.color) return r.color;
  // alternate base color by checker pattern (classic European 4-in-1 visual)
  if ((r.row + r.col) % 2 === 1) {
    return params.altColor;
  }
  return params.ringColor;
}
  // --------------------------------------------------------------------------
  // DRAWING
  // --------------------------------------------------------------------------
  function draw(ctx: CanvasRenderingContext2D, cssW: number, cssH: number) {
    ctx.save();
    ctx.clearRect(0, 0, cssW, cssH);

    // background
    ctx.fillStyle = params.bgColor;
    ctx.fillRect(0, 0, cssW, cssH);
    // ----- IMAGE PREVIEW DRAW -----
     // always center → scale → offset
    ctx.translate(cssW / 2, cssH / 2);
    ctx.scale(scale, scale);
    ctx.translate(offset.x - worldW / 2, offset.y - worldH / 2);

    // bounds box
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(
      -params.innerDiameter,
      -params.innerDiameter,
      worldW + params.innerDiameter * 2,
      worldH + params.innerDiameter * 2
    );

    const wantHighlight = !!highlightHex && !!highlightSupplier;

    // ----- BEGIN RING DRAWING -----

    const SQUASH_Y = 0.75; // vertical squash for projection
    const edge = Math.max(1.25, params.wireDiameter * 0.35) / scale;

    // quarter arcs: right, bottom, left, top
    const arcQuarters: [number, number][] = [
      [0, Math.PI / 2],
      [Math.PI / 2, Math.PI],
      [Math.PI, (3 * Math.PI) / 2],
      [(3 * Math.PI) / 2, Math.PI * 2],
    ];

function drawRingSegment(r: Ring, start: number, end: number, color: string) {
  // Use world units; ctx.scale(...) will take care of pixels.
  const wire = params.wireDiameter / 2;       // ❌ no "/ scale"
  const outerR = r.radius + wire;
  const innerR = r.radius - wire;

  ctx.beginPath();
  ctx.arc(0, 0, outerR, start, end, false);
  ctx.arc(0, 0, innerR, end, start, true);
  ctx.closePath();

  // Subtle metallic shading that preserves the actual ring color
  const grad = ctx.createRadialGradient(0, 0, innerR, 0, 0, outerR);
  grad.addColorStop(0, lightenColor(color, 0.30));
  grad.addColorStop(0.5, color);
  grad.addColorStop(1, darkenColor(color, 0.25));
  ctx.fillStyle = grad;
  ctx.fill();

  // Outline in world units (so it scales with zoom)
  ctx.strokeStyle = "#000";
  ctx.lineWidth = Math.max(0.1, params.wireDiameter * 0.25);  // thinner than band
  ctx.stroke();
}
function lightenColor(hex: string, amount: number) {
  const { r, g, b } = hexToRgb(hex);
  const mix = (c: number) => Math.min(255, Math.floor(c + (255 - c) * amount));
  return `rgb(${mix(r)}, ${mix(g)}, ${mix(b)})`;
}

function darkenColor(hex: string, amount: number) {
  const { r, g, b } = hexToRgb(hex);
  const mix = (c: number) => Math.max(0, Math.floor(c * (1 - amount)));
  return `rgb(${mix(r)}, ${mix(g)}, ${mix(b)})`;
}
    function drawRingWeave(r: Ring, pass: number, color: string) {
      ctx.save();
      ctx.translate(r.x, r.y);
      ctx.scale(1, SQUASH_Y);

// FIXED (row+col parity → proper alternation)
const overQuarters = (r.row + r.col) % 2 === 0 ? [0, 2] : [1, 3];

      arcQuarters.forEach((arc, idx) => {
        const isOver = overQuarters.includes(idx);
        if ((isOver && pass === 1) || (!isOver && pass === 0)) {
          drawRingSegment(r, arc[0], arc[1], color);
        }
      });

      ctx.restore();
    }

    // two passes: under first, then over
    for (let pass = 0; pass < 2; pass++) {
      for (const r of rings) {
		const c = r.previewColor || r.color || ringColorFallback(r);

        const hit =
          wantHighlight &&
          (r.color?.toUpperCase() === highlightHex.toUpperCase()) &&
          r.supplier === highlightSupplier;

        if (hit && pass === 0) {
          ctx.save();
          ctx.translate(r.x, r.y);
          ctx.scale(1, SQUASH_Y);
          ctx.strokeStyle = "rgba(255,255,0,0.5)";
          ctx.lineWidth = Math.max(2, (params.wireDiameter * 1.6) / scale);
          ctx.beginPath();
          ctx.arc(0, 0, r.radius + 2 / scale, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        drawRingWeave(r, pass, c);
      }
    }

    // selected ring outline (scaled to ellipse projection)
    if (selectedRing) {
      ctx.save();
      ctx.translate(selectedRing.x, selectedRing.y);
      ctx.scale(1, SQUASH_Y);
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2 / scale;
      ctx.beginPath();
      ctx.arc(0, 0, selectedRing.radius + 3 / scale, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
    }

    // ----- END RING DRAWING -----
  }

  // --------------------------------------------------------------------------
  // COORDINATE HELPERS
  // --------------------------------------------------------------------------
  function screenToWorld(clientX: number, clientY: number) {
    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const cssW = rect.width;
    const cssH = rect.height;

    // screen → canvas centered coords
    const sx = clientX - rect.left - cssW / 2;
    const sy = clientY - rect.top - cssH / 2;

    // undo transforms: scale then offset shift
    return {
      x: sx / scale - offset.x + worldW / 2,
      y: sy / scale - offset.y + worldH / 2,
    };
  }

  // --------------------------------------------------------------------------
  // TOUCH & MOUSE INTERACTIONS
  // --------------------------------------------------------------------------
  function onWheel(e: React.WheelEvent<HTMLCanvasElement>) {
    // 🚫 Disable mouse wheel zoom, slider is the only zoom control
    e.preventDefault();
    return;
  }

  function onMouseDown(e: React.MouseEvent<HTMLCanvasElement>) {
    if (paintMode || eraserMode) {
      snapshot();
      setIsPainting(true);
      const { x, y } = screenToWorld(e.clientX, e.clientY);
      paintAt(x, y);
    } else if (panZoomEnabled) {
      setIsPanning(true);
      panStart.current = { x: e.clientX - offset.x, y: e.clientY - offset.y };
    }
  }

  function onMouseMove(e: React.MouseEvent<HTMLCanvasElement>) {
    if (isPainting && (paintMode || eraserMode)) {
      const { x, y } = screenToWorld(e.clientX, e.clientY);
      paintAt(x, y);
    } else if (isPanning && panStart.current) {
      setOffset({
        x: e.clientX - panStart.current.x,
        y: e.clientY - panStart.current.y,
      });
    }
  }

  function onMouseUp() {
    setIsPainting(false);
    setIsPanning(false);
    panStart.current = null;
  }

  function onClick(e: React.MouseEvent<HTMLCanvasElement>) {
    const { x, y } = screenToWorld(e.clientX, e.clientY);
    const hit = hitTest(x, y);
    setSelectedRing(hit ?? null);
  }

  function handleTouchStart(e: React.TouchEvent<HTMLCanvasElement>) {
    e.preventDefault();
    if (e.touches.length === 1) {
      const { clientX, clientY } = e.touches[0];

      if (paintMode || eraserMode) {
        snapshot();
        setIsPainting(true);
        const { x, y } = screenToWorld(clientX, clientY);
        paintAt(x, y);
      } else if (panZoomEnabled && touchPanZoomEnabled) {
        panStart.current = {
          x: clientX - offset.x,
          y: clientY - offset.y,
        };
        setIsPanning(true);
      }
    }
  }

  function handleTouchMove(e: React.TouchEvent<HTMLCanvasElement>) {
    e.preventDefault();
    if (e.touches.length === 1) {
      const { clientX, clientY } = e.touches[0];

      if (isPainting && (paintMode || eraserMode)) {
        const { x, y } = screenToWorld(clientX, clientY);
        paintAt(x, y);
      } else if (isPanning && panZoomEnabled && touchPanZoomEnabled && panStart.current) {
        setOffset({
          x: clientX - panStart.current.x,
          y: clientY - panStart.current.y,
        });
      }
    }
  }

  function handleTouchEnd() {
    setIsPainting(false);
    setIsPanning(false);
    panStart.current = null;
  }

  // --------------------------------------------------------------------------
  // PAINTING
  // --------------------------------------------------------------------------
function paintAt(wx: number, wy: number) {
  const hit = hitTest(wx, wy);
  if (!hit) return;

  snapshot();

  setRings((prev) =>
    prev.map((r) =>
      r.row === hit.row && r.col === hit.col
        ? {
            ...r,
            color: eraserMode ? undefined : currentBrushColor,
            supplier: eraserMode ? undefined : params.supplier,
          }
        : r
    )
  );
}
  function hitTest(wx: number, wy: number): Ring | null {
    const tol = params.wireDiameter * 0.75; // pick tolerance
    for (const r of rings) {
      const dx = wx - r.x;
      const dy = wy - r.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist <= r.radius + tol) return r;
    }
    return null;
  }

  // --------------------------------------------------------------------------
  // IMAGE MAPPING — APPLY IMAGE COLORS TO RINGS
  // --------------------------------------------------------------------------
async function mapImageToRings(previewOnly: boolean) {
  if (!imageFile || !canvasRef.current) return;

  const { width, height } = worldSize(params);
  const data = await rasterizeImageToRGBA(
    imageFile,
    Math.round(width),
    Math.round(height),
    imageScale,
    previewOffset,
    previewRotation
  );

  const getColor = (x: number, y: number) => {
    const ix = Math.floor(x);
    const iy = Math.floor(y);
    if (ix < 0 || iy < 0 || ix >= data.width || iy >= data.height) return "#000000";
    const i = (iy * data.width + ix) * 4;
    const r = data.data[i];
    const g = data.data[i + 1];
    const b = data.data[i + 2];
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
  };

  // Pick which color palette to use
  const palette =
    paletteSource === "cmj"
      ? SUPPLIER_COLORS.cmj
      : paletteSource === "trl"
      ? SUPPLIER_COLORS.trl
      : paletteSource === "mdz"
      ? SUPPLIER_COLORS.mdz
      : paletteSource === "current"
      ? SUPPLIER_COLORS[params.supplier]
      : SUPPLIERS.flatMap((s) => SUPPLIER_COLORS[s.id]);

  const paletteRGB = palette.map((p) => ({ ...p, rgb: hexToRgb(p.hex) }));

  const newRings = rings.map((r) => {
    const px = Math.floor((r.x / width) * data.width);
    const py = Math.floor((r.y / height) * data.height);
    const ringColor = getColor(px, py);
    const ringRGB = hexToRgb(ringColor);

    // Find nearest palette color
    let best = paletteRGB[0];
    let bestDist = rgbDist2(ringRGB, best.rgb);
    for (const p of paletteRGB) {
      const d = rgbDist2(ringRGB, p.rgb);
      if (d < bestDist) {
        bestDist = d;
        best = p;
      }
    }

    return previewOnly
      ? { ...r, previewColor: best.hex } // For preview mode only
      : { ...r, color: best.hex, supplier: params.supplier };
  });

  if (!previewOnly) {
    snapshot();
    setRings(newRings);
  }

  draw(canvasRef.current!.getContext("2d")!, viewSize, viewSize);
}
// --------------------------------------------------------------------------
// LIVE IMAGE PREVIEW (auto-refresh overlay colors)
// --------------------------------------------------------------------------
useEffect(() => {
  if (imageFile) {
    mapImageToRings(true); // live preview mode
  }
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [imageFile, imageScale, previewOffset, previewRotation, paletteSource]);
  // --------------------------------------------------------------------------
  // VIEW HELPERS
  // --------------------------------------------------------------------------
  function resetView() {
    setOffset({ x: 0, y: 0 });
    setScale(1);
  }

  function fitToView() {
    const { width, height } = worldSize(params);
    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const scaleX = (rect.width - pad * 2) / width;
    const scaleY = (rect.height - pad * 2) / height;
    const best = Math.min(scaleX, scaleY);

    setScale(best);
    setOffset({ x: 0, y: 0 });
  }

  function centerView() {
    const canvas = canvasRef.current;
    if (!canvas) return;
    setOffset({ x: 0, y: 0 });
  }

  function oneToOne() {
    setScale(1);
    const canvas = canvasRef.current;
    if (!canvas) return;
    setOffset({ x: 0, y: 0 });
  }

  // --------------------------------------------------------------------------
  // BILL OF MATERIALS (RING COUNTS, COLOR COUNTS, SUPPLIERS)
  // --------------------------------------------------------------------------
  const bom = useMemo(() => {
    const colorCounts: Record<string, number> = {};
    const supplierCounts: Record<string, number> = {};
    for (const r of rings) {
      const c = r.color ?? params.ringColor;
      colorCounts[c] = (colorCounts[c] ?? 0) + 1;
      if (r.supplier) {
        supplierCounts[r.supplier] = (supplierCounts[r.supplier] ?? 0) + 1;
      }
    }
    return { colorCounts, supplierCounts };
  }, [rings, params.ringColor]);

  // --------------------------------------------------------------------------
  // USAGE ROWS + TOTAL PACKS (for sidebar + Print Preview)
  // --------------------------------------------------------------------------
  const usageRows = useMemo(() => {
    const rows: {
      supplier: string;
      supplierId: SupplierId;
      name: string;
      hex: string;
      count: number;
      packs: number;
      swg?: string;
      id?: string;
      ar?: string;
      url: string;
    }[] = [];

    // Group counts by supplier + hex
    const grouped: Record<string, { supplierId: SupplierId; hex: string; count: number }> = {};

    for (const r of rings) {
      if (!r.color || !r.supplier) continue;
      const key = `${r.supplier}-${r.color.toUpperCase()}`;
      if (!grouped[key]) {
        grouped[key] = { supplierId: r.supplier, hex: r.color, count: 0 };
      }
      grouped[key].count++;
    }

    // Build rows from grouped data
    for (const { supplierId, hex, count } of Object.values(grouped)) {
      const supplierEntry = SUPPLIERS.find((s) => s.id === supplierId);
      const supplier = supplierEntry?.name ?? "";
      const url = supplierEntry?.url ?? "";
      const name = supplierColorName(supplierId, hex);

      rows.push({
        supplier,
        supplierId,
        name,
        hex,
        count,
        packs: Math.ceil(count / FIXED_PACK_SIZE),
        swg: params.ringSpec.includes("swg") ? params.ringSpec.split(" ")[1] : undefined,
        id: params.ringSpec.includes('"') ? params.ringSpec.split(" ")[0] : undefined,
        ar: params.ringSpec.includes("AR") ? params.ringSpec.split("AR")[1] : undefined,
        url,
      });
    }

    return rows;
  }, [rings, params.ringSpec]);

  const totalPacks = useMemo(() => {
    return usageRows.reduce((sum, r) => sum + r.packs, 0);
  }, [usageRows]);

  // --------------------------------------------------------------------------
  // SCROLL LOCK EFFECT (prevents background scroll when overlays are open)
  // --------------------------------------------------------------------------
  useEffect(() => {
    const shouldLock = showAbout || showPrintPreview || scrollLocked;

    const prevOverflow = document.body.style.overflow;
    const prevTouch = document.body.style.touchAction;

    if (shouldLock) {
      document.body.style.overflow = "hidden";
      document.body.style.touchAction = "none";
      document.documentElement.style.overflow = "hidden";
      document.documentElement.style.touchAction = "none";
    } else {
      document.body.style.overflow = "";
      document.body.style.touchAction = "auto";
      document.documentElement.style.overflow = "";
      document.documentElement.style.touchAction = "auto";
    }

    return () => {
      document.body.style.overflow = prevOverflow;
      document.body.style.touchAction = prevTouch;
      document.documentElement.style.overflow = "";
      document.documentElement.style.touchAction = "auto";
    };
  }, [showAbout, showPrintPreview, scrollLocked]);

  // --------------------------------------------------------------------------
  // ESCAPE KEY HANDLER
  // --------------------------------------------------------------------------
  useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (e.key === "Escape") {
        if (showAbout) setShowAbout(false);
        if (showPrintPreview) setShowPrintPreview(false);
      }
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [showAbout, showPrintPreview]);
  
  // --------------------------------------------------------------------------
  // UI — RETURN
  // --------------------------------------------------------------------------
  return (
    <div className="h-screen w-screen bg-slate-900 text-slate-100 grid grid-rows-[auto,1fr]">
      {/* ✅ EULA modal always on top when needed */}
      <EulaDialog />

      {/* ===================== TOP BAR ===================== */}
      <div className="w-full border-b border-slate-800 bg-slate-950/70 backdrop-blur px-3 py-3">
        {/* Title / Zoom / Undo / Redo / Print */}
        <div className="flex flex-wrap items-center gap-2 mb-3">
          <div className="text-lg font-semibold mr-4">Chainmaille Designer • 4-in-1</div>

          <button onClick={fitToView} className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-xs">Fit</button>
          <button onClick={centerView} className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-xs">Center</button>
          <div className="px-2 py-1 rounded border border-slate-700 text-xs">Zoom: {scale.toFixed(2)}×</div>

          <div className="ml-4 flex items-center gap-2">
            <button onClick={undo} className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-xs">Undo</button>
            <button onClick={redo} className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-xs">Redo</button>
            
            
            {/* Print: compute tiling + make page images from the current canvas */}
            <Paywall feature="Print 1:1">
              <button
                onClick={() => {
                  // 🚫 Block free users from printing bigger than 5×5
                  if (params.rows > 5 || params.cols > 5) {
                    alert("Upgrade required to print designs larger than 5×5.");
                    return;
                  }

                  const canvas = canvasRef.current;
                  if (!canvas) return;

                  // compute how many pages fit @96dpi screen pixels, Letter 8.5x11in
                  const pxPerMm = 96 / 25.4;
                  const pageWmm = 216; // 8.5in
                  const pageHmm = 279; // 11in
                  const pageWpx = pageWmm * pxPerMm;
                  const pageHpx = pageHmm * pxPerMm;

                  const newPagesX = Math.ceil(canvas.width / pageWpx);
                  const newPagesY = Math.ceil(canvas.height / pageHpx);
                  setPagesX(newPagesX);
                  setPagesY(newPagesY);

                  // Slice the current canvas into per-page images
                  const urls: string[] = [];
                  for (let py = 0; py < newPagesY; py++) {
                    for (let px = 0; px < newPagesX; px++) {
                      const sx = px * pageWpx;
                      const sy = py * pageHpx;
                      const sw = Math.min(pageWpx, canvas.width - sx);
                      const sh = Math.min(pageHpx, canvas.height - sy);

                      const pageCanvas = document.createElement("canvas");
                      pageCanvas.width = sw;
                      pageCanvas.height = sh;
                      const pageCtx = pageCanvas.getContext("2d")!;
                      pageCtx.drawImage(canvas, sx, sy, sw, sh, 0, 0, sw, sh);

                      urls.push(pageCanvas.toDataURL("image/png"));
                    }
                  }

                  setPrintPages(urls);
                  setShowPrintPreview(true);
                }}
                className="px-2 py-1 bg-slate-700 rounded text-xs hover:bg-slate-600"
              >
                Print 1:1
              </button>
            </Paywall>

            <div className="flex items-center gap-2">
              <label className="text-xs">Zoom:</label>
              <input
                type="range"
                min={0.1}
                max={5}
                step={0.05}
                value={scale}
                onChange={(e) => setScale(parseFloat(e.target.value))}
                className="w-32"
              />
              <span className="text-xs">{scale.toFixed(2)}×</span>
            </div>

            <button
              onClick={() => {
                if (window.confirm("Clear the entire chainmail sheet?")) {
                  snapshot();
                  setRings(generateRings(params)); // resets to blank
                }
              }}
              className="px-2 py-1 rounded bg-red-700 hover:bg-red-600 text-xs"
            >
              Reset Chain
            </button>

            <button
              onClick={() => setShowAbout(true)}
              className="px-2 py-1 rounded bg-purple-700 hover:bg-purple-600 text-xs"
            >
              About
            </button>
          </div>

          {/* Selected ring banner */}
          <div className="ml-auto text-xs flex items-center gap-2 px-2 py-1 rounded bg-slate-800 border border-slate-700">
            <span className="text-slate-300">Selected:</span>
            {selectedRing ? (
              <>
                <span>(row {selectedRing.row}, col {selectedRing.col})</span>
                <span
                  className="inline-block h-3 w-3 rounded-full border"
                  style={{ backgroundColor: ringColorFallback(selectedRing) }}
                  title={ringColorFallback(selectedRing)}
                />
                <span className="text-slate-400">
                  {selectedRing.supplier
                    ? SUPPLIERS.find((s) => s.id === selectedRing.supplier)?.name
                    : "—"}
                </span>
              </>
            ) : (
              <span>None</span>
            )}
          </div>
        </div>
      </div>
      
      {/* ===================== CONTROL ROWS ===================== */}
      <div className="flex flex-wrap gap-4">
{/* ---- Sheet ---- */}
<div className="space-y-2 p-3 bg-slate-900/50 rounded-lg min-w-[220px]">
  <div className="text-xs uppercase tracking-wide text-slate-400 mb-1">Sheet</div>
  <div className="grid grid-cols-2 gap-3">
    {/* Rows */}
    <div className="flex items-center gap-2">
      <label className="text-xs w-16">Rows:</label>
      <input
        type="range"
        min={5}
        max={400}
        value={params.rows}
        onChange={(e) => {
          const newRows = parseInt(e.target.value);
          if (!unlocked && newRows > 5) {
            alert("Upgrade required to go beyond 5 rows.");
            setParams({ ...params, rows: 5 });
            return;
          }
          setParams({ ...params, rows: newRows });
        }}
        className="flex-1"
      />
      <input
        type="number"
        min={5}
        max={400}
        value={params.rows}
        onChange={(e) =>
          setParams({ ...params, rows: parseInt(e.target.value) })
        }
        className="w-16 bg-slate-800 border border-slate-700 rounded px-1 text-right text-xs"
      />
    </div>

    {/* Cols */}
    <div className="flex items-center gap-2">
      <label className="text-xs w-16">Cols:</label>
      <input
        type="range"
        min={5}
        max={400}
        value={params.cols}
        onChange={(e) => {
          const newCols = parseInt(e.target.value);
          if (!unlocked && newCols > 5) {
            alert("Upgrade required to go beyond 5 columns.");
            setParams({ ...params, cols: 5 });
            return;
          }
          setParams({ ...params, cols: newCols });
        }}
        className="flex-1"
      />
      <input
        type="number"
        min={5}
        max={400}
        value={params.cols}
        onChange={(e) =>
          setParams({ ...params, cols: parseInt(e.target.value) })
        }
        className="w-16 bg-slate-800 border border-slate-700 rounded px-1 text-right text-xs"
      />
    </div>
  </div>
</div>

{/* ---- Geometry ---- */}
<div className="space-y-2 p-3 bg-slate-900/50 rounded-lg min-w-[260px]">
  <div className="text-xs uppercase tracking-wide text-slate-400 mb-1">Geometry</div>
  <div className="grid grid-cols-1 gap-3">
    {/* Inner Diameter */}
    <div className="flex items-center gap-2">
      <label className="text-xs w-20">Inner Ø:</label>
      <input
        type="range"
        min={2}
        max={20}
        step={0.1}
        value={params.innerDiameter}
        onChange={(e) =>
          setParams({ ...params, innerDiameter: parseFloat(e.target.value) })
        }
        className="flex-1"
      />
      <input
        type="number"
        min={2}
        max={20}
        step={0.1}
        value={params.innerDiameter}
        onChange={(e) =>
          setParams({ ...params, innerDiameter: parseFloat(e.target.value) })
        }
        className="w-16 bg-slate-800 border border-slate-700 rounded px-1 text-right text-xs"
      />
    </div>

    {/* Wire Diameter */}
    <div className="flex items-center gap-2">
      <label className="text-xs w-20">Wire Ø:</label>
      <input
        type="range"
        min={0.6}
        max={4}
        step={0.1}
        value={params.wireDiameter}
        onChange={(e) =>
          setParams({ ...params, wireDiameter: parseFloat(e.target.value) })
        }
        className="flex-1"
      />
      <input
        type="number"
        min={0.6}
        max={4}
        step={0.1}
        value={params.wireDiameter}
        onChange={(e) =>
          setParams({ ...params, wireDiameter: parseFloat(e.target.value) })
        }
        className="w-16 bg-slate-800 border border-slate-700 rounded px-1 text-right text-xs"
      />
    </div>

    {/* Overlap X */}
    <div className="flex items-center gap-2">
      <label className="text-xs w-20">Overlap X:</label>
      <input
        type="range"
        min={0}
        max={0.8}
        step={0.01}
        value={params.overlapX}
        onChange={(e) =>
          setParams({ ...params, overlapX: parseFloat(e.target.value) })
        }
        className="flex-1"
      />
      <input
        type="number"
        min={0}
        max={0.8}
        step={0.01}
        value={params.overlapX}
        onChange={(e) =>
          setParams({ ...params, overlapX: parseFloat(e.target.value) })
        }
        className="w-16 bg-slate-800 border border-slate-700 rounded px-1 text-right text-xs"
      />
    </div>

    {/* Overlap Y */}
    <div className="flex items-center gap-2">
      <label className="text-xs w-20">Overlap Y:</label>
      <input
        type="range"
        min={0}
        max={0.8}
        step={0.01}
        value={params.overlapY}
        onChange={(e) =>
          setParams({ ...params, overlapY: parseFloat(e.target.value) })
        }
        className="flex-1"
      />
      <input
        type="number"
        min={0}
        max={0.8}
        step={0.01}
        value={params.overlapY}
        onChange={(e) =>
          setParams({ ...params, overlapY: parseFloat(e.target.value) })
        }
        className="w-16 bg-slate-800 border border-slate-700 rounded px-1 text-right text-xs"
      />
    </div>
  </div>
</div>
        {/* ---- Supplier & Size ---- */}
        <div className="space-y-2 p-3 bg-slate-900/50 rounded-lg min-w-[220px]">
          <div className="text-xs uppercase tracking-wide text-slate-400 mb-1">
            Supplier & Size
          </div>
          <select
            value={params.supplier}
            onChange={(e) =>
              setParams({ ...params, supplier: e.target.value as SupplierId })
            }
            className="w-full rounded bg-slate-800 p-2 mb-2"
          >
            {SUPPLIERS.map((s) => (
              <option key={s.id} value={s.id}>
                {s.name}
              </option>
            ))}
          </select>
          <select
            value={params.ringSpec}
            onChange={(e) => {
              const spec = RING_SPECS.find((r) => r.label === e.target.value);
              if (spec)
                setParams({
                  ...params,
                  ringSpec: spec.label,
                  innerDiameter: spec.inner,
                  wireDiameter: spec.wire,
                });
            }}
            className="w-full rounded bg-slate-800 p-2"
          >
            {RING_SPECS.map((r) => (
              <option key={r.label} value={r.label}>
                {r.label}
              </option>
            ))}
          </select>
        </div>

        {/* ---- Colors ---- */}
        <div className="space-y-2 p-3 bg-slate-900/50 rounded-lg min-w-[220px]">
          <div className="text-xs uppercase tracking-wide text-slate-400 mb-1">
            Colors
          </div>
          <div className="grid grid-cols-3 gap-2">
            <input
              type="color"
              value={params.ringColor}
              onChange={(e) =>
                setParams({ ...params, ringColor: e.target.value })
              }
            />
            <input
              type="color"
              value={params.altColor}
              onChange={(e) =>
                setParams({ ...params, altColor: e.target.value })
              }
            />
            <input
              type="color"
              value={params.bgColor}
              onChange={(e) =>
                setParams({ ...params, bgColor: e.target.value })
              }
            />
          </div>
        </div>

        {/* ---- Tools ---- */}
        <div className="space-y-2 p-3 bg-slate-900/50 rounded-lg min-w-[260px]">
          <div className="text-xs uppercase tracking-wide text-slate-400 mb-1">
            Tools
          </div>
          <div className="grid grid-cols-3 gap-2">
            <button
              onClick={() => {
                setPaintMode((v) => !v);
                if (eraserMode) setEraserMode(false);
              }}
              className={`px-2 py-1 rounded ${
                paintMode ? "bg-green-700" : "bg-slate-600"
              }`}
            >
              {paintMode ? "Paint: ON" : "Paint: OFF"}
            </button>

            <button
              onClick={() => {
                setEraserMode((v) => !v);
                if (paintMode) setPaintMode(false);
              }}
              className={`px-2 py-1 rounded ${
                eraserMode ? "bg-red-700" : "bg-slate-600"
              }`}
            >
              {eraserMode ? "Eraser: ON" : "Eraser: OFF"}
            </button>

            <button
              onClick={() => setPanZoomEnabled((v) => !v)}
              className={`px-2 py-1 rounded ${
                panZoomEnabled ? "bg-blue-700" : "bg-slate-600"
              }`}
            >
              {panZoomEnabled ? "Pan: ON" : "Pan: OFF"}
            </button>
          </div>

          {/* 1:1 reset button */}
          <button
            onClick={oneToOne}
            className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700 text-xs"
          >
            1:1
          </button>

          {/* Scroll lock toggle */}
          <button
            onClick={() => setScrollLocked((v) => !v)}
            className={`px-2 py-1 rounded text-xs ${
              scrollLocked
                ? "bg-green-700 hover:bg-green-600"
                : "bg-slate-700 hover:bg-slate-600"
            }`}
          >
            {scrollLocked ? "Scroll: LOCKED" : "Scroll: UNLOCKED"}
          </button>
        </div>

        {/* ---- Supplier Palette ---- */}
        <div className="space-y-2 p-3 bg-slate-900/50 rounded-lg flex-1 min-w-[260px]">
          <div className="text-xs uppercase tracking-wide text-slate-400 mb-1">
            Palette
          </div>
          <div className="flex flex-wrap gap-2">
            {SUPPLIER_COLORS[params.supplier].map(({ name, hex }) => (
              <button
                key={`${params.supplier}-${name}`}
                title={name}
                style={{ backgroundColor: hex }}
                className="h-6 w-6 rounded-full border border-white/70"
                onClick={() => {
                  setCurrentBrushColor(hex);
                  // Direct-assign selected ring if not in paint/erase mode
                  if (!paintMode && !eraserMode && selectedRing) {
                    snapshot();
                    setRings((prev) =>
                      prev.map((r) =>
                        selectedRing &&
                        r.row === selectedRing.row &&
                        r.col === selectedRing.col
                          ? { ...r, color: hex, supplier: params.supplier }
                          : r
                      )
                    );
                  }
                }}
              />
            ))}
          </div>
        </div>
      </div>
      {/* ===================== MAIN: CANVAS + SIDEBAR ===================== */}
      <div className="grid grid-cols-[1fr,360px] min-h-0">
        {/* Canvas region */}
        <div ref={wrapRef} className="bg-slate-800 overflow-auto relative min-h-0">
          {/* Image overlay controls */}
          <ImageOverlayPanel
            imageFile={imageFile}
            setImageFile={setImageFile}
            imageScale={imageScale}
            setImageScale={setImageScale}
            paletteSource={paletteSource}
            setPaletteSource={setPaletteSource}
            onApplyTransfer={() => mapImageToRings(false)} // single transfer
            previewOffset={previewOffset}
            setPreviewOffset={setPreviewOffset}
            previewRotation={previewRotation}
            setPreviewRotation={setPreviewRotation}
          />

{/* New Zoom + View Size sliders under file controls */}
<div className="p-3 space-y-4">
  {/* Zoom Control */}
  <div className="flex items-center gap-2">
    <label className="text-xs w-20">Zoom:</label>
    <input
      type="range"
      min={0.1}
      max={20}
      step={0.1}
      value={scale}
      onChange={(e) => setScale(parseFloat(e.target.value))}
      className="flex-1"
    />
    <input
      type="number"
      min={0.1}
      max={20}
      step={0.1}
      value={scale}
      onChange={(e) => setScale(parseFloat(e.target.value))}
      className="w-20 bg-slate-800 border border-slate-700 rounded px-1 text-right text-xs"
    />
  </div>

  {/* View Size Control */}
  <div className="flex items-center gap-2">
    <label className="text-xs w-20">View Size:</label>
    <input
      type="range"
      min={200}
      max={1000}
      step={10}
      value={viewSize}
      onChange={(e) => setViewSize(parseInt(e.target.value))}
      className="flex-1"
    />
    <input
      type="number"
      min={200}
      max={1000}
      step={10}
      value={viewSize}
      onChange={(e) => setViewSize(parseInt(e.target.value))}
      className="w-20 bg-slate-800 border border-slate-700 rounded px-1 text-right text-xs"
    />
  </div>
</div>

          {/* Canvas */}
          <canvas
            id="chainmail-canvas"
            ref={canvasRef}
            onWheel={onWheel}
            onMouseDown={onMouseDown}
            onMouseMove={onMouseMove}
            onMouseUp={onMouseUp}
            onClick={onClick}
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            className={`${
              paintMode || eraserMode
                ? "cursor-crosshair"
                : isPanning
                ? "cursor-grabbing"
                : "cursor-grab"
            }`}
            style={{
              width: `${viewSize}px`,
              height: `${viewSize}px`,
            }}
          />
          <div className="absolute bottom-2 left-2 text-[10px] text-slate-300 bg-slate-900/60 border border-slate-700 rounded px-2 py-1">
            Wheel: zoom • Drag: pan • Paint/Eraser toggles in Tools
          </div>
        </div>

        {/* Right sidebar */}
        <div className="border-l border-slate-800 p-3 overflow-auto">
          {/* Selected Ring */}
          <div className="text-xs uppercase tracking-wide text-slate-400 mb-2">
            Selected Ring
          </div>
          <div className="bg-slate-800 rounded p-2 text-xs mb-4">
            {selectedRing ? (
              <div className="space-y-1">
                <div>
                  Row: {selectedRing.row} • Col: {selectedRing.col}
                </div>
                <div className="flex items-center gap-2">
                  <span>Color:</span>
                  <span
                    className="inline-block h-3 w-3 rounded-full border"
                    style={{ backgroundColor: ringColorFallback(selectedRing) }}
                  />
                  <span>
                    {supplierColorName(
                      selectedRing.supplier ?? params.supplier,
                      ringColorFallback(selectedRing)
                    )}
                  </span>
                </div>
                <div>
                  Supplier:{" "}
                  {selectedRing.supplier
                    ? SUPPLIERS.find((s) => s.id === selectedRing.supplier)?.name
                    : "—"}
                </div>
              </div>
            ) : (
              <div className="text-slate-400">No ring selected.</div>
            )}
          </div>

          {/* BOM / Usage */}
          <div className="text-xs uppercase tracking-wide text-slate-400 mb-2">
            Color Usage (packs @ {FIXED_PACK_SIZE})
          </div>
          <div className="space-y-1 mb-2 text-xs">
            {usageRows.map(
              ({ supplier, supplierId, name, hex, count, packs, swg, id, ar, url }) => (
                <div
                  key={`${supplier}-${name}-${hex}`}
                  className="flex flex-col bg-slate-800 rounded px-2 py-1"
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <span
                        className="inline-block h-3 w-3 rounded-full border"
                        style={{ backgroundColor: hex }}
                      />
                      <span>{supplier} • {name}</span>
                    </div>
                    <span>
                      {count} rings • {packs} packs
                    </span>
                  </div>
                  <div className="text-slate-400 text-[10px] pl-6">
                    Gauge: {swg || "—"} • ID: {id || "—"} • AR: {ar || "—"}
                  </div>
                  <div className="flex items-center gap-2 text-[10px] pl-6 mt-1">
                    <button
                      className="px-2 py-0.5 rounded bg-slate-700"
                      onClick={() => {
                        setHighlightSupplier(supplierId);
                        setHighlightHex(hex);
                      }}
                    >
                      Highlight
                    </button>
                    {url && (
                      <a
                        href={url}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="px-2 py-0.5 rounded bg-slate-600 hover:bg-slate-500"
                      >
                        Visit Supplier
                      </a>
                    )}
                  </div>
                </div>
              )
            )}
          </div>
          <div className="text-right text-xs text-slate-300 mb-4">
            Total packs: {totalPacks}
          </div>
        </div>
      </div>

      {/* ===================== PRINT PREVIEW OVERLAY ===================== */}
      {showPrintPreview && (
        <PrintPreviewOverlay
          pagesX={pagesX}
          pagesY={pagesY}
          usageRows={usageRows}
          totalPacks={totalPacks}
          printPages={printPages}
          onCancel={() => setShowPrintPreview(false)}
        />
      )}

      {/* ===================== ABOUT DIALOG ===================== */}
      <dialog
        open={showAbout}
        className="p-6 rounded-lg max-w-md bg-white text-black shadow-lg"
        style={{
          zIndex: 2147483647,
          position: "fixed",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
        }}
      >
        <h2 className="text-xl font-bold mb-4">About</h2>
        <p className="mb-2">
          This app was created by <strong>Micah Forstein</strong> for his wife{" "}
          <strong>Erin Forstein</strong>’s 50th birthday as a special present.
        </p>
        <p className="mb-4">
          Erin is my muse and inspiration for everything I do, and I love her deeply.
        </p>
        <p className="mb-4">
          You can see Erin’s beautiful chainmaille creations here:{" "}
          <a
            href="https://www.etsy.com/shop/WovenRainbowsByErin"
            target="_blank"
            rel="noopener noreferrer"
            className="text-blue-600 underline"
          >
            Woven Rainbows by Erin
          </a>
        </p>
        <div className="flex justify-end gap-2">
          <button
            onClick={() => setShowAbout(false)}
            className="px-3 py-1 rounded bg-gray-700 text-white"
          >
            Close
          </button>
        </div>
      </dialog>
    </div>
  );
}