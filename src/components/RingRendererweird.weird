// ==============================
// src/components/RingRenderer.tsx
// ==============================
import React, {
  useEffect,
  useRef,
  useState,
  forwardRef,
  useImperativeHandle,
} from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

// ---------------- Types ----------------
export type Ring = { row: number; col: number; x: number; y: number; radius: number };

export interface RenderParams {
  rows: number;
  cols: number;
  innerDiameter: number;
  wireDiameter: number;
  ringColor: string;
  bgColor: string;
}

export type PaintMap = Map<string, string | null>;

type Props = {
  rings: Ring[];
  params: RenderParams;
  paint: PaintMap;
  setPaint: React.Dispatch<React.SetStateAction<PaintMap>>;
  initialPaintMode?: boolean;
  initialEraseMode?: boolean;
  initialRotationLocked?: boolean;
  activeColor: string;
};

// ============================================================
// Imperative API
// ============================================================
export type RingRendererHandle = {
  zoomIn: () => void;
  zoomOut: () => void;
  resetView: () => void;
  toggleLock: () => void;
  setPaintMode: (on: boolean) => void;
  toggleErase: () => void;
  clearPaint: () => void;
  lock2DView: () => void;
  forceLockRotation: (locked: boolean) => void;
  getState: () => {
    paintMode: boolean;
    eraseMode: boolean;
    rotationLocked: boolean;
  };
};

// ============================================================
// Main Renderer Component
// ============================================================
function RingRendererBase(
  {
    rings,
    params,
    paint,
    setPaint,
    initialPaintMode = true,
    initialEraseMode = false,
    initialRotationLocked = true,
    activeColor,
  }: Props,
  ref: React.Ref<RingRendererHandle>
) {
  // -----------------------------------------------
  // Refs for scene, camera, controls, and meshes
  // -----------------------------------------------
  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene>();
  const cameraRef = useRef<THREE.PerspectiveCamera>();
  const rendererRef = useRef<THREE.WebGLRenderer>();
  const controlsRef = useRef<OrbitControls>();
  const meshesRef = useRef<THREE.Mesh[]>([]);

  // -----------------------------------------------
  // Local state + synchronized refs
  // -----------------------------------------------
  const [localPaintMode, setLocalPaintMode] = useState<boolean>(initialPaintMode);
  const [localEraseMode, setLocalEraseMode] = useState<boolean>(initialEraseMode);
  const [rotationLocked, setRotationLocked] = useState<boolean>(initialRotationLocked);

  const paintModeRef = useRef(localPaintMode);
  const eraseModeRef = useRef(localEraseMode);
  const lockRef = useRef(rotationLocked);
  const activeColorRef = useRef(activeColor);
  const paintRef = useRef(paint);

  useEffect(() => { paintModeRef.current = localPaintMode; }, [localPaintMode]);
  useEffect(() => { eraseModeRef.current = localEraseMode; }, [localEraseMode]);
  useEffect(() => { lockRef.current = rotationLocked; }, [rotationLocked]);
  useEffect(() => { activeColorRef.current = activeColor; }, [activeColor]);
  useEffect(() => { paintRef.current = paint; }, [paint]);

  const initialZRef = useRef<number>(200);
  const initialTargetRef = useRef<THREE.Vector3>(new THREE.Vector3(0, 0, 0));
  const lastFitKeyRef = useRef<string>("");

  // -----------------------------------------------
  // Scene initialization
  // -----------------------------------------------
  useEffect(() => {
    if (!mountRef.current) return;
    const mount = mountRef.current;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(params.bgColor || "#0F1115");
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(45, mount.clientWidth / mount.clientHeight, 0.1, 5000);
    camera.position.set(0, 0, 240);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mount.clientWidth, mount.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    mount.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(3, 5, 10);
    scene.add(dir);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enableZoom = true;
    controls.enablePan = true;
    controls.enableRotate = !initialRotationLocked;
    controlsRef.current = controls;

    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    return () => {
      mount.removeChild(renderer.domElement);
      renderer.dispose();
    };
  }, []);

// -----------------------------------------------
// Mesh rebuild when geometry or color changes
// -----------------------------------------------
useEffect(() => {
  const scene = sceneRef.current;
  const camera = cameraRef.current;
  const controls = controlsRef.current;
  if (!scene || !camera || !controls) return;

  // Cleanup old meshes
  meshesRef.current.forEach((m) => {
    scene.remove(m);
    m.geometry.dispose();
    if (Array.isArray(m.material)) m.material.forEach((mat) => mat.dispose());
    else m.material.dispose();
  });

  // âœ… Scale millimeters to visible scene units
  const mmToUnits = 500;
  const ringRadius = ((params.innerDiameter + params.wireDiameter) / 2) * mmToUnits;
  const wireRadius = (params.wireDiameter / 2) * mmToUnits;
  const ringGeo = new THREE.TorusGeometry(ringRadius, wireRadius, 16, 100);

  const group = new THREE.Group();
  const meshes: THREE.Mesh[] = [];

  rings.forEach((r) => {
    const geo = ringGeo.clone();
    const mat = new THREE.MeshStandardMaterial({
      color: params.ringColor,
      metalness: 0.85,
      roughness: 0.25,
    });
    const mesh = new THREE.Mesh(geo, mat);

    // âœ… Position scaled to match mmToUnits
    mesh.position.set(r.x * mmToUnits, -r.y * mmToUnits, 0);
    mesh.rotation.y = r.row % 2 === 0 ? 0.25 : -0.25;
    (mesh as any).ringKey = `${r.row},${r.col}`;
    meshes.push(mesh);
    group.add(mesh);
  });

  // Apply any painted colors
  paint.forEach((color, key) => {
    const m = meshes.find((x: any) => x.ringKey === key);
    if (m && color) (m.material as THREE.MeshStandardMaterial).color.set(color);
  });

  meshesRef.current = meshes;
  scene.add(group);
// ðŸŸ¢ Add a visible green cube at the center for debugging
const debugCube = new THREE.Mesh(
  new THREE.BoxGeometry(100, 100, 100),
  new THREE.MeshBasicMaterial({ color: 0x00ff00 })
);
scene.add(debugCube);
  // âœ… Camera auto-fit to visible frame
  const bbox = new THREE.Box3().setFromObject(group);
  const size = bbox.getSize(new THREE.Vector3());
  const center = bbox.getCenter(new THREE.Vector3());
  const maxDim = Math.max(size.x, size.y);
  const fov = (camera.fov * Math.PI) / 180;
  const fitHeightDistance = maxDim / (2 * Math.tan(fov / 2));
  const distance = fitHeightDistance * 1.2; // Add padding
camera.position.set(center.x, center.y, 2000); // force closer
  camera.position.set(center.x, center.y, distance);
  camera.lookAt(center);
  controls.target.copy(center);
  controls.update();

  rendererRef.current?.render(scene, camera);

  initialZRef.current = distance;
  initialTargetRef.current.copy(center);

  console.log("ðŸŽ¯ Auto-fit complete:", {
    distance,
    maxDim,
    rings: rings.length,
  });

  return () => {
    scene.remove(group);
    group.traverse((obj: any) => {
      if (obj.isMesh) {
        obj.geometry.dispose();
        if (Array.isArray(obj.material))
          obj.material.forEach((mat) => mat.dispose());
        else obj.material.dispose();
      }
    });
  };
}, [rings, params.innerDiameter, params.wireDiameter, params.ringColor]);

  // âœ… Ensure auto-fit runs after render (1 frame delay)
  useEffect(() => {
    requestAnimationFrame(() => {
      const scene = sceneRef.current;
      const camera = cameraRef.current;
      const controls = controlsRef.current;
      const meshes = meshesRef.current;
      if (!scene || !camera || !controls || !meshes.length) return;

      const group = new THREE.Group();
      meshes.forEach((m) => group.add(m));
      const bbox = new THREE.Box3().setFromObject(group);
      const size = bbox.getSize(new THREE.Vector3());
      const center = bbox.getCenter(new THREE.Vector3());

// Add padding so the rings fit comfortably
const maxDim = Math.max(size.x, size.y);
const distance = Math.max(maxDim * 1.2, 50); // 50 = minDistance fallback



      camera.position.set(center.x, center.y, distance);
      controls.target.copy(center);
      controls.update();
      rendererRef.current?.render(scene, camera);

      initialZRef.current = distance;
      initialTargetRef.current.copy(center);
    });
  }, [rings, params.innerDiameter, params.wireDiameter]);
// âœ… Auto-fit and make sure rings are visible
  // -----------------------------------------------
  // Painting & Pointer Interaction
  // -----------------------------------------------
  useEffect(() => {
    const scene = sceneRef.current;
    const camera = cameraRef.current;
    const renderer = rendererRef.current;
    if (!scene || !camera || !renderer) return;

    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    let painting = false;
    let panning = false;
    let last = { x: 0, y: 0 };
    const activePointers = new Set<number>();

    const paintAt = (clientX: number, clientY: number) => {
      const rect = renderer.domElement.getBoundingClientRect();
      ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      ndc.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(meshesRef.current, false);
      if (hits.length > 0) {
        const key = (hits[0].object as any).ringKey as string;
        setPaint((prev) => {
          const n = new Map(prev);
          const colorToApply = eraseModeRef.current ? params.ringColor : activeColorRef.current;
          n.set(key, colorToApply);
          return n;
        });
      }
    };

    const el = renderer.domElement;
    const onDown = (e: PointerEvent) => {
      e.preventDefault();
      e.stopPropagation();
      activePointers.add(e.pointerId);
      if (activePointers.size > 1) return;
      if (paintModeRef.current) {
        painting = true;
        paintAt(e.clientX, e.clientY);
      } else {
        panning = true;
        last = { x: e.clientX, y: e.clientY };
      }
    };

    const onMove = (e: PointerEvent) => {
      if (activePointers.size > 1) return;
      e.preventDefault();
      e.stopPropagation();
      if (painting && paintModeRef.current) {
        paintAt(e.clientX, e.clientY);
      } else if (panning && !paintModeRef.current) {
        if (lockRef.current && cameraRef.current && controlsRef.current) {
          const cam = cameraRef.current;
          const ctr = controlsRef.current;
          const dx = e.clientX - last.x;
          const dy = e.clientY - last.y;
          last = { x: e.clientX, y: e.clientY };
          const fovRad = (cam.fov * Math.PI) / 180;
          const halfHWorld = Math.tan(fovRad / 2) * cam.position.z;
          const halfWWorld = halfHWorld * cam.aspect;
          const perPixelX = (halfWWorld * 2) / renderer.domElement.clientWidth;
          const perPixelY = (halfHWorld * 2) / renderer.domElement.clientHeight;
          const moveX = -dx * perPixelX;
          const moveY = dy * perPixelY;
          cam.position.x += moveX;
          cam.position.y += moveY;
          ctr.target.x += moveX;
          ctr.target.y += moveY;
          ctr.update();
        }
      }
    };

    const onUp = (e: PointerEvent) => {
      e.preventDefault();
      e.stopPropagation();
      activePointers.delete(e.pointerId);
      if (activePointers.size === 0) {
        painting = false;
        panning = false;
      }
    };

    el.addEventListener("pointerdown", onDown);
    el.addEventListener("pointermove", onMove);
    el.addEventListener("pointerup", onUp);

    return () => {
      el.removeEventListener("pointerdown", onDown);
      el.removeEventListener("pointermove", onMove);
      el.removeEventListener("pointerup", onUp);
    };
  }, [params.ringColor, activeColor]);
  // -----------------------------------------------
  // Controls Mapping
  // -----------------------------------------------
  useEffect(() => {
    const ctr = controlsRef.current;
    if (!ctr) return;

    if (localPaintMode) {
      // Paint: freeze camera drag, allow wheel zoom
      ctr.enableRotate = false;
      ctr.enablePan = false;
      ctr.enableZoom = true;
      ctr.mouseButtons = {
        LEFT: THREE.MOUSE.NONE,
        RIGHT: THREE.MOUSE.NONE,
        MIDDLE: THREE.MOUSE.DOLLY,
      };
    } else if (rotationLocked) {
      // 2D view: pan + zoom, no rotation
      ctr.enableRotate = false;
      ctr.enablePan = true;
      ctr.enableZoom = true;
      ctr.mouseButtons = {
        LEFT: THREE.MOUSE.PAN,
        RIGHT: THREE.MOUSE.PAN,
        MIDDLE: THREE.MOUSE.DOLLY,
      };
    } else {
      // 3D free rotation
      ctr.enableRotate = true;
      ctr.enablePan = true;
      ctr.enableZoom = true;
      ctr.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        RIGHT: THREE.MOUSE.PAN,
        MIDDLE: THREE.MOUSE.DOLLY,
      };
    }
    ctr.update();
  }, [rotationLocked, localPaintMode]);

  // -----------------------------------------------
  // Sync mesh colors when paint map changes
  // -----------------------------------------------
  useEffect(() => {
    const meshes = meshesRef.current;
    if (!meshes) return;
    meshes.forEach((m: any) => {
      const mat = m.material as THREE.MeshStandardMaterial;
      const key = m.ringKey;
      const color = paint.get(key) ?? params.ringColor;
      mat.color.set(color);
    });
  }, [paint, params.ringColor]);

  // -----------------------------------------------
  // Imperative Handle (API for parent component)
  // -----------------------------------------------
  useImperativeHandle(ref, (): RingRendererHandle => ({
    zoomIn: () => {
      const cam = cameraRef.current;
      const ctr = controlsRef.current;
      if (!cam || !ctr) return;
      const dir = new THREE.Vector3();
      dir.subVectors(ctr.target, cam.position).normalize();
      cam.position.addScaledVector(dir, 0.1 * cam.position.distanceTo(ctr.target));
      ctr.update();
    },
    zoomOut: () => {
      const cam = cameraRef.current;
      const ctr = controlsRef.current;
      if (!cam || !ctr) return;
      const dir = new THREE.Vector3();
      dir.subVectors(cam.position, ctr.target).normalize();
      cam.position.addScaledVector(dir, 0.1 * cam.position.distanceTo(ctr.target));
      ctr.update();
    },
    resetView: () => {
      const cam = cameraRef.current;
      const ctr = controlsRef.current;
      if (!cam || !ctr) return;
      cam.position.set(0, 0, initialZRef.current);
      ctr.target.copy(initialTargetRef.current);
      ctr.update();
      rendererRef.current?.render(sceneRef.current!, cam);
    },
    toggleLock: () => {
      setRotationLocked((v) => {
        const newVal = !v;
        lockRef.current = newVal;
        const ctr = controlsRef.current;
        if (ctr) {
          ctr.enableRotate = !newVal;
          ctr.mouseButtons = newVal
            ? { LEFT: THREE.MOUSE.PAN, RIGHT: THREE.MOUSE.PAN, MIDDLE: THREE.MOUSE.DOLLY }
            : { LEFT: THREE.MOUSE.ROTATE, RIGHT: THREE.MOUSE.PAN, MIDDLE: THREE.MOUSE.DOLLY };
          ctr.update();
        }
        return newVal;
      });
    },
    setPaintMode: (on: boolean) => setLocalPaintMode(on),
    toggleErase: () => setLocalEraseMode((v) => !v),
    clearPaint: () => setPaint(new Map()),

    lock2DView: () => {
      setRotationLocked(true);
      const cam = cameraRef.current;
      const ctr = controlsRef.current;
      if (cam && ctr) {
        cam.position.set(0, 0, initialZRef.current);
        ctr.target.copy(initialTargetRef.current);
        ctr.enableRotate = false;
        ctr.enablePan = true;
        ctr.mouseButtons = {
          LEFT: THREE.MOUSE.PAN,
          RIGHT: THREE.MOUSE.ROTATE,
          MIDDLE: THREE.MOUSE.DOLLY,
        };
        ctr.update();
        rendererRef.current?.render(sceneRef.current!, cam);
      }
    },
    forceLockRotation: (locked: boolean) => {
      setRotationLocked(locked);
      lockRef.current = locked;
      const ctr = controlsRef.current;
      if (ctr) {
        ctr.enableRotate = !locked;
        ctr.enablePan = true;
        ctr.mouseButtons = locked
          ? { LEFT: THREE.MOUSE.PAN, RIGHT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY }
          : { LEFT: THREE.MOUSE.ROTATE, RIGHT: THREE.MOUSE.PAN, MIDDLE: THREE.MOUSE.DOLLY };
        ctr.update();
      }
    },
    getState: () => ({
      paintMode: paintModeRef.current,
      eraseMode: eraseModeRef.current,
      rotationLocked: lockRef.current,
    }),
  }));

  // -----------------------------------------------
  // Render container
  // -----------------------------------------------
  return (
    <div style={{ position: "relative", width: "100vw", height: "100vh" }}>
      <div ref={mountRef} style={{ width: "100%", height: "100%" }} />
    </div>
  );
}

// âœ… Wrap with forwardRef
const RingRenderer = forwardRef<RingRendererHandle, Props>(RingRendererBase);
export default RingRenderer;

// ============================================================
// Geometry generator (uses OUTER diameter & overlaps correctly)
// ============================================================
export function generateRings(p: {
  rows: number;
  cols: number;
  innerDiameter: number; // mm
  wireDiameter: number;  // mm
  overlapX?: number;     // 0..1
  overlapY?: number;     // 0..1
}): Ring[] {
  const rings: Ring[] = [];

  const id = p.innerDiameter;
  const wd = p.wireDiameter;
  const outer = id + 2 * wd;

  const ox = typeof p.overlapX === "number" ? p.overlapX : 0.3;
  const oy = typeof p.overlapY === "number" ? p.overlapY : 0.3;

  const pitchX = outer * (1 - ox);
  const pitchY = outer * Math.sin(Math.PI / 3) * (1 - oy);

  for (let r = 0; r < p.rows; r++) {
    const offsetX = (r % 2 === 0 ? 0 : pitchX / 2);
    for (let c = 0; c < p.cols; c++) {
      rings.push({
        row: r,
        col: c,
        x: c * pitchX + offsetX,
        y: r * pitchY,
        radius: (id + wd) / 2,
      });
    }
  }
  return rings;
}