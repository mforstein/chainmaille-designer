// File: src/components/RingRenderer.tsx

import React, {
  useEffect,
  useRef,
  useState,
  forwardRef,
  useImperativeHandle,
} from "react";
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
import SpriteText from "three-spritetext";
import { OverlayState } from "../components/ImageOverlayPanel"; // ‚úÖ Path confirmed

// ============================================================
// === Constants & Helpers ===================================
// ============================================================
const INCH_TO_MM = 25.4;

export function parseInchFractionToInches(v: string | number): number {
  if (typeof v === "number") return v;
  const s = v.replace(/"/g, "").trim();
  if (s.includes("/")) {
    const [num, den] = s.split("/").map(Number);
    if (!isFinite(num) || !isFinite(den) || den === 0)
      throw new Error(`Invalid inch fraction: ${v}`);
    return num / den;
  }
  const n = Number(s);
  if (!isFinite(n)) throw new Error(`Invalid inch numeric value: ${v}`);
  return n;
}

export function inchesToMm(inches: number) {
  return inches * INCH_TO_MM;
}

export function computeRingVarsFixedID(
  idInput: string | number,
  wdMm: string | number
) {
  let ID_mm: number;

  if (typeof idInput === "number" && idInput > 25) {
    ID_mm = idInput;
  } else {
    const id_in = parseInchFractionToInches(idInput);
    ID_mm = inchesToMm(id_in);
  }

  const WD_mm = typeof wdMm === "number" ? wdMm : Number(wdMm);
  if (!isFinite(WD_mm)) throw new Error(`Invalid WD: ${wdMm}`);

  const OD_mm = ID_mm + 2 * WD_mm;
  const AR = ID_mm / WD_mm;

  return {
    ID_mm,
    WD_mm,
    OD_mm,
    AR,
    ID_mm_disp: +ID_mm.toFixed(4),
    WD_mm_disp: +WD_mm.toFixed(3),
    OD_mm_disp: +OD_mm.toFixed(4),
    AR_disp: +AR.toFixed(3),
  };
}

// ============================================================
// === Types ==================================================
export type Ring = {
  row: number;
  col: number;
  x: number;
  y: number;
  z?: number;
  radius: number;
  innerDiameter?: number;
  wireDiameter?: number;
  centerSpacing?: number;
  rotationX?: number;
  rotationY?: number;
  rotationZ?: number;
  tiltRad?: number;
  _chartLabel?: SpriteText;
};

export interface RenderParams {
  rows: number;
  cols: number;
  innerDiameter: number;
  wireDiameter: number;
  ringColor: string;
  bgColor: string;
  centerSpacing?: number;
}

export type PaintMap = Map<string, string | null>;

type Props = {
  rings: Ring[];
  params: RenderParams;
  paint: PaintMap;
  setPaint: React.Dispatch<React.SetStateAction<PaintMap>>;
  initialPaintMode?: boolean;
  initialEraseMode?: boolean;
  initialRotationLocked?: boolean;
  activeColor: string;
  overlay?: OverlayState | null;
};

export type RingRendererHandle = {
  zoomIn: () => void;
  zoomOut: () => void;
  resetView: () => void;
  toggleLock: () => void;
  setPaintMode: (on: boolean) => void;
  toggleErase: () => void;
  clearPaint: () => void;
  lock2DView: () => void;
  forceLockRotation: (locked: boolean) => void;
  applyOverlay: (overlay: OverlayState) => void;

  /** ‚úÖ NEW: Sample the overlay image and colorize rings */
  applyOverlayToRings: (overlay: OverlayState) => Promise<void>;

  getState: () => {
    paintMode: boolean;
    eraseMode: boolean;
    rotationLocked: boolean;
  };
};

// ============================================================
// === Utility: Camera Dolly =================================
function dollyCamera(
  camera: THREE.PerspectiveCamera,
  controls: OrbitControls | undefined,
  factor: number
) {
  if (controls && typeof (controls as any).dollyIn === "function") {
    if (factor > 1) (controls as any).dollyIn(factor);
    else (controls as any).dollyOut(1 / factor);
    controls.update();
    return;
  }
  const target = controls ? controls.target : new THREE.Vector3(0, 0, 0);
  const dir = new THREE.Vector3()
    .subVectors(camera.position, target)
    .multiplyScalar(factor);
  camera.position.copy(target).add(dir);
  camera.updateProjectionMatrix();
}

// ============================================================
// === Main Component ========================================
const RingRenderer = forwardRef<RingRendererHandle, Props>(function RingRenderer(
  {
    rings,
    params,
    paint,
    setPaint,
    initialPaintMode = true,
    initialEraseMode = false,
    initialRotationLocked = true,
    activeColor,
    overlay,
  },
  ref
) {
  // ‚úÖ SAFETY GUARD to prevent "Cannot read bgColor"
  const safeParams = {
    rows: params?.rows ?? 1,
    cols: params?.cols ?? 1,
    innerDiameter: params?.innerDiameter ?? 6,
    wireDiameter: params?.wireDiameter ?? 1,
    ringColor: params?.ringColor ?? "#CCCCCC",
    bgColor: params?.bgColor ?? "#0F1115",
    centerSpacing: params?.centerSpacing ?? 7.5,
  };

  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene>();
  if (typeof window !== "undefined") (window as any).sceneRef = sceneRef;
  const cameraRef = useRef<THREE.PerspectiveCamera>();
  const rendererRef = useRef<THREE.WebGLRenderer>();
  const controlsRef = useRef<OrbitControls>();
  const meshesRef = useRef<THREE.Mesh[]>([]);
  const groupRef = useRef<THREE.Group>();

  // ‚úÖ Overlay system
  const overlayMeshRef = useRef<THREE.Mesh>();
  const [overlayParams, setOverlayParams] = useState<OverlayState | null>(null);

  // Local UI states
  const [localPaintMode, setLocalPaintMode] = useState(initialPaintMode);
  const [localEraseMode, setLocalEraseMode] = useState(initialEraseMode);
  const [rotationLocked, setRotationLocked] = useState(initialRotationLocked);

  // Refs to mirror real-time states
  const paintModeRef = useRef(localPaintMode);
  const eraseModeRef = useRef(localEraseMode);
  const lockRef = useRef(rotationLocked);
  const activeColorRef = useRef(activeColor);
  const paintRef = useRef(paint);
  const paramsRef = useRef(safeParams);

  useEffect(() => { paintModeRef.current = localPaintMode; }, [localPaintMode]);
  useEffect(() => { eraseModeRef.current = localEraseMode; }, [localEraseMode]);
  useEffect(() => { lockRef.current = rotationLocked; }, [rotationLocked]);
  useEffect(() => { activeColorRef.current = activeColor; }, [activeColor]);
  useEffect(() => { paintRef.current = paint; }, [paint]);
  useEffect(() => { paramsRef.current = safeParams; }, [safeParams]);

  const initialZRef = useRef(240);
  const initialTargetRef = useRef(new THREE.Vector3(0, 0, 0));
    // ============================================================
  // Init Scene / Renderer
  useEffect(() => {
    if (!mountRef.current) return;
    const mount = mountRef.current;

    if (rendererRef.current) {
      try {
        rendererRef.current.dispose();
        rendererRef.current.forceContextLoss();
        mount.replaceChildren();
      } catch (err) {
        console.warn("Renderer cleanup failed:", err);
      }
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(safeParams.bgColor);
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(
      45,
      mount.clientWidth / mount.clientHeight,
      0.1,
      2000
    );
    camera.position.set(0, 0, initialZRef.current);
    cameraRef.current = camera;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mount.clientWidth, mount.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.domElement.style.touchAction = "none";
    mount.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    scene.add(new THREE.AmbientLight(0xffffff, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 1.15);
    dir.position.set(4, 6, 10);
    scene.add(dir);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.screenSpacePanning = true;
    controls.enableZoom = true;
    controls.enablePan = true;
    controls.enableRotate = !initialRotationLocked;
    controls.zoomSpeed = 1.1;
    controls.touches = { ONE: THREE.TOUCH.PAN, TWO: THREE.TOUCH.DOLLY_PAN } as any;
    controlsRef.current = controls;

    const preventTouchZoom = (e: TouchEvent) => {
      if (e.touches.length > 1) e.preventDefault();
    };
    renderer.domElement.addEventListener("touchstart", preventTouchZoom, { passive: false });
    renderer.domElement.addEventListener("touchmove", preventTouchZoom, { passive: false });

    const onResize = () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    };
    window.addEventListener("resize", onResize);
    onResize();

    // ===============================
    // Painting system
    // ===============================
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    let painting = false;
    const activePointers = new Set<number>();

    const paintAt = (clientX: number, clientY: number) => {
      const rect = renderer.domElement.getBoundingClientRect();
      ndc.x = ((clientX - rect.left) / rect.width) * 2 - 1;
      ndc.y = -((clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(meshesRef.current, false);
      if (hits.length > 0) {
        const key = (hits[0].object as any).ringKey as string;
        setPaint((prev) => {
          const n = new Map(prev);
          const colorToApply = eraseModeRef.current ? null : activeColorRef.current;
          n.set(key, colorToApply);
          return n;
        });
      }
    };

    const onDown = (e: PointerEvent) => {
      e.preventDefault();
      activePointers.add(e.pointerId);
      if (activePointers.size > 1) return;
      if (paintModeRef.current && lockRef.current) {
        painting = true;
        paintAt(e.clientX, e.clientY);
      }
    };
    const onMove = (e: PointerEvent) => {
      if (activePointers.size > 1) return;
      if (painting && paintModeRef.current && lockRef.current) {
        e.preventDefault();
        paintAt(e.clientX, e.clientY);
      }
    };
    const onUp = (e: PointerEvent) => {
      activePointers.delete(e.pointerId);
      if (activePointers.size === 0) painting = false;
    };

    renderer.domElement.addEventListener("pointerdown", onDown);
    renderer.domElement.addEventListener("pointermove", onMove);
    renderer.domElement.addEventListener("pointerup", onUp);

    // ===============================
    // Animation loop
    // ===============================
    const animate = () => {
      requestAnimationFrame(animate);

      const baseColor = paramsRef.current.ringColor;
      for (const m of meshesRef.current) {
        const key = (m as any).ringKey as string;
        const color = paintRef.current.get(key) ?? baseColor;
        (m.material as THREE.MeshStandardMaterial).color.set(color);
      }

      if (controlsRef.current) {
        const c = controlsRef.current;
        const locked = lockRef.current;
        const paintingActive = paintModeRef.current;

        c.enableRotate = !locked;
        c.enablePan = !paintingActive;
        if (paintingActive) {
          c.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
          };
        } else if (locked) {
          c.mouseButtons = {
            LEFT: THREE.MOUSE.PAN,
            MIDDLE: THREE.MOUSE.PAN,
            RIGHT: THREE.MOUSE.PAN,
          };
          c.enableRotate = false;
        } else {
          c.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY,
            RIGHT: THREE.MOUSE.PAN,
          };
        }

        c.update();
      }

      renderer.render(scene, camera);
    };
    animate();

    // Cleanup
    return () => {
      window.removeEventListener("resize", onResize);
      renderer.domElement.removeEventListener("pointerdown", onDown);
      renderer.domElement.removeEventListener("pointermove", onMove);
      renderer.domElement.removeEventListener("pointerup", onUp);
      renderer.domElement.removeEventListener("touchstart", preventTouchZoom);
      renderer.domElement.removeEventListener("touchmove", preventTouchZoom);

      if (sceneRef.current) {
        sceneRef.current.traverse((obj: any) => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material))
              obj.material.forEach((m: any) => m.dispose());
            else obj.material.dispose();
          }
        });
        sceneRef.current.clear();
      }

      try {
        mount.removeChild(renderer.domElement);
      } catch {}
      controls.dispose();
      renderer.dispose();
      renderer.forceContextLoss?.();
      rendererRef.current = undefined;
      sceneRef.current = undefined;
    };
  }, [safeParams.bgColor, setPaint]);
// ============================================================
// Geometry Build (Rings) ‚Äî Optimized with InstancedMesh
// ============================================================
useEffect(() => {
  const scene = sceneRef.current;
  if (!scene) return;

  // üßπ Clean up previous geometry/materials
  if (groupRef.current) {
    groupRef.current.traverse((o: any) => {
      if (o.geometry) o.geometry.dispose();
      if (o.material) o.material.dispose?.();
    });
    scene.remove(groupRef.current);
    meshesRef.current = [];
  }

  // üß© Create new group
  const group = new THREE.Group();
  groupRef.current = group;

  if (!Array.isArray(rings) || rings.length === 0) return;

  // ‚úÖ Base geometry and material shared by all rings
  const baseRingRadius =
    safeParams.innerDiameter / 2 + safeParams.wireDiameter / 2;
  const baseTubeRadius = safeParams.wireDiameter / 2;
  const baseGeometry = new THREE.TorusGeometry(
    baseRingRadius,
    baseTubeRadius,
    16, // fewer segments = less memory, still looks smooth
    48
  );
  const baseMaterial = new THREE.MeshStandardMaterial({
    color: safeParams.ringColor,
    metalness: 0.85,
    roughness: 0.25,
  });

  // ‚úÖ Instanced mesh for all rings
  const instancedMesh = new THREE.InstancedMesh(
    baseGeometry,
    baseMaterial,
    rings.length
  );

  // Optional: enable per-instance color
  instancedMesh.instanceColor = new THREE.InstancedBufferAttribute(
    new Float32Array(rings.length * 3),
    3
  );

  const dummy = new THREE.Object3D();
  const color = new THREE.Color();

  rings.forEach((r, i) => {
    // Sanitize values
    if (!Number.isFinite(r.innerDiameter) || r.innerDiameter! <= 0)
      r.innerDiameter = 5;
    if (!Number.isFinite(r.wireDiameter) || r.wireDiameter! <= 0)
      r.wireDiameter = 1;
    const spacing = r.centerSpacing ?? 7.5;
    if (!Number.isFinite(spacing) || spacing <= 0 || spacing > 100)
      r.centerSpacing = 7.5;

    if (!Number.isFinite(r.x)) r.x = i * r.centerSpacing!;
    if (!Number.isFinite(r.y)) r.y = 0;
    if (!Number.isFinite(r.z)) r.z = 0;

    // Set transform for each instance
    dummy.position.set(r.x, -r.y, r.z ?? 0);
    if (typeof r.tiltRad === "number") dummy.rotation.set(0, r.tiltRad, 0);
    dummy.updateMatrix();
    instancedMesh.setMatrixAt(i, dummy.matrix);

    // Set color per instance
    color.set(safeParams.ringColor);
    instancedMesh.setColorAt(i, color);
  });

  instancedMesh.instanceMatrix.needsUpdate = true;
  instancedMesh.instanceColor!.needsUpdate = true;

  // ‚úÖ Add instanced mesh to scene
  group.add(instancedMesh);

  // Handle optional text labels (like chart labels)
  rings.forEach((r) => {
    if ((r as any)._chartLabel instanceof SpriteText) {
      const label = (r as any)._chartLabel;
      label.material.depthTest = false;
      label.material.depthWrite = false;
      group.add(label);
    }
  });

  // ‚úÖ Center the group in view
  const box = new THREE.Box3().setFromObject(group);
  const center = box.getCenter(new THREE.Vector3());
  group.position.sub(center);
  scene.add(group);

  // ‚úÖ Store refs for painting and updating colors later
  meshesRef.current = [instancedMesh];
}, [rings, safeParams.ringColor, safeParams.innerDiameter, safeParams.wireDiameter]);
  // ============================================================
  // === Overlay Plane =========================================
  // ============================================================
  useEffect(() => {
    const scene = sceneRef.current;
    if (!scene) return;

    // remove old overlay
    if (overlayMeshRef.current) {
      scene.remove(overlayMeshRef.current);
      overlayMeshRef.current.geometry.dispose();
      (overlayMeshRef.current.material as THREE.Material).dispose();
      overlayMeshRef.current = undefined;
    }

    if (!overlayParams?.dataUrl) return;

    // load new texture
    const loader = new THREE.TextureLoader();
    loader.load(overlayParams.dataUrl, (texture) => {
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;

      const aspect =
        texture.image && texture.image.height > 0
          ? texture.image.width / texture.image.height
          : 1;

      const planeHeight = 400;
      const planeWidth = planeHeight * aspect;

      const geo = new THREE.PlaneGeometry(planeWidth, planeHeight);
      const mat = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: overlayParams.opacity ?? 0.7,
        depthWrite: false,
      });

      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(overlayParams.offsetX ?? 0, overlayParams.offsetY ?? 0, -50);
      mesh.rotation.z = THREE.MathUtils.degToRad(overlayParams.rotation ?? 0);
      mesh.scale.set(overlayParams.scale ?? 1, overlayParams.scale ?? 1, 1);

      //scene.add(mesh);
      overlayMeshRef.current = mesh;
    });

    return () => {
      if (overlayMeshRef.current) {
        scene.remove(overlayMeshRef.current);
        overlayMeshRef.current.geometry.dispose();
        (overlayMeshRef.current.material as THREE.Material).dispose();
        overlayMeshRef.current = undefined;
      }
    };
  }, [overlayParams]);
  // ============================================================
  // === Overlay (Reactive from Parent Prop) ====================
  // ============================================================
  useEffect(() => {
    const scene = sceneRef.current;
    if (!scene) return;

    // üßπ Clean up any existing overlay
    if (overlayMeshRef.current) {
      scene.remove(overlayMeshRef.current);
      overlayMeshRef.current.geometry.dispose();
      (overlayMeshRef.current.material as THREE.Material).dispose();
      overlayMeshRef.current = undefined;
    }

    // üí§ No overlay provided
    if (!overlay?.dataUrl) return;

    // üé® Load and display texture from prop
    const loader = new THREE.TextureLoader();
    loader.load(overlay.dataUrl, (texture) => {
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
      texture.needsUpdate = true;

      const aspect =
        texture.image && texture.image.height > 0
          ? texture.image.width / texture.image.height
          : 1;

      const planeHeight = 400;
      const planeWidth = planeHeight * aspect;

      const geo = new THREE.PlaneGeometry(planeWidth, planeHeight);
      const mat = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: overlay.opacity ?? 0.8,
        depthWrite: false,
      });

      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(overlay.offsetX ?? 0, overlay.offsetY ?? 0, -60);
      mesh.rotation.z = THREE.MathUtils.degToRad(overlay.rotation ?? 0);
      mesh.scale.set(overlay.scale ?? 1, overlay.scale ?? 1, 1);

      scene.add(mesh);
      overlayMeshRef.current = mesh;
    });

    return () => {
      if (overlayMeshRef.current) {
        scene.remove(overlayMeshRef.current);
        overlayMeshRef.current.geometry.dispose();
        (overlayMeshRef.current.material as THREE.Material).dispose();
        overlayMeshRef.current = undefined;
      }
    };
  }, [overlay]); // ‚úÖ Trigger when overlay prop changes
  /** Clamp utility */
const clamp01 = (v: number) => Math.max(0, Math.min(1, v));

/** Rotate a 2D point around origin by radians */
function rotate2D(x: number, y: number, rad: number) {
  const c = Math.cos(rad), s = Math.sin(rad);
  return { x: x * c - y * s, y: x * s + y * c };
}

/** Load an HTMLImageElement from a dataURL */
function loadImage(dataUrl: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = (e) => reject(e);
    img.src = dataUrl;
  });
}
// ============================================================
// === Imperative Handle =====================================
// ============================================================
useImperativeHandle(ref, () => ({
  zoomIn: () => {
    if (!cameraRef.current) return;
    dollyCamera(cameraRef.current, controlsRef.current, 0.9);
  },
  zoomOut: () => {
    if (!cameraRef.current) return;
    dollyCamera(cameraRef.current, controlsRef.current, 1.1);
  },
  resetView: () => {
    const cam = cameraRef.current;
    const ctr = controlsRef.current;
    if (!cam || !ctr) return;
    cam.position.set(0, 0, initialZRef.current);
    ctr.target.copy(initialTargetRef.current);
    ctr.update();
  },
  toggleLock: () => {
    setRotationLocked((prev) => !prev);
  },
  setPaintMode: (on: boolean) => {
    setLocalPaintMode(on);
  },
  toggleErase: () => {
    setLocalEraseMode((prev) => !prev);
  },
  clearPaint: () => {
    setPaint(new Map());
  },
  lock2DView: () => {
    const cam = cameraRef.current;
    if (cam) cam.position.set(0, 0, initialZRef.current);
    setRotationLocked(true);
  },
  forceLockRotation: (locked: boolean) => {
    setRotationLocked(locked);
  },
  getState: () => ({
    paintMode: paintModeRef.current,
    eraseMode: eraseModeRef.current,
    rotationLocked: lockRef.current,
  }),

 
  // ‚úÖ Improved: Apply overlay stretched to entire chainmail grid
  applyOverlayToRings: async (overlay: OverlayState) => {
    try {
      if (!overlay?.dataUrl || !groupRef.current) return;

      // --- Load image into offscreen canvas ---
      const img = await new Promise<HTMLImageElement>((resolve, reject) => {
        const i = new Image();
        i.onload = () => resolve(i);
        i.onerror = reject;
        i.src = overlay.dataUrl!;
      });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      const { data, width: W, height: H } = ctx.getImageData(0, 0, img.width, img.height);

      // --- Compute bounds for ring field ---
      const box = new THREE.Box3().setFromObject(groupRef.current);
      const size = new THREE.Vector3();
      box.getSize(size);
      const widthWorld = size.x || 1;
      const heightWorld = size.y || 1;
      const centerX = (box.min.x + box.max.x) / 2;
      const centerY = (box.min.y + box.max.y) / 2;

      const scale = overlay.scale ?? 1;
      const rotDeg = overlay.rotation ?? 0;
      const rotRad = THREE.MathUtils.degToRad(rotDeg);
      const offX = overlay.offsetX ?? 0;
      const offY = overlay.offsetY ?? 0;

      const clamp01 = (v: number) => Math.max(0, Math.min(1, v));
      const rotate2D = (x: number, y: number, rad: number) => {
        const c = Math.cos(rad), s = Math.sin(rad);
        return { x: x * c - y * s, y: x * s + y * c };
      };

      setPaint((prev) => {
        const next = new Map(prev);
        const temp = new THREE.Vector3();

        for (const m of meshesRef.current) {
          m.getWorldPosition(temp);

          // üîπ Normalize ring position to -0.5..+0.5 across entire grid
          let nx = (temp.x - centerX) / widthWorld;
          let ny = (temp.y - centerY) / heightWorld;

          // üîπ Apply offset (in normalized grid units)
          nx -= (offX / 100) / scale;
          ny -= (offY / 100) / scale;

          // üîπ Apply rotation + scale
          const rotated = rotate2D(nx, ny, rotRad);
          nx = rotated.x / scale;
          ny = rotated.y / scale;

          // üîπ Map to UV [0..1] (inverted y)
          const u = clamp01(nx + 0.5);
          const v = clamp01(0.5 - ny);

          const px = Math.min(W - 1, Math.max(0, Math.round(u * (W - 1))));
          const py = Math.min(H - 1, Math.max(0, Math.round(v * (H - 1))));
          const idx = (py * W + px) * 4;

          const r8 = data[idx + 0];
          const g8 = data[idx + 1];
          const b8 = data[idx + 2];

          const hex =
            "#" +
            r8.toString(16).padStart(2, "0") +
            g8.toString(16).padStart(2, "0") +
            b8.toString(16).padStart(2, "0");

          const key = (m as any).ringKey as string;
          next.set(key, hex);
        }

        console.log("‚úÖ Overlay applied across full grid");
        return next;
      });
    } catch (err) {
      console.error("‚ùå applyOverlayToRings failed:", err);
    }
  },
}));
  // ============================================================
  // === Sync state for loop consistency ========================
  // ============================================================
  useEffect(() => {
    paintModeRef.current = localPaintMode;
    eraseModeRef.current = localEraseMode;
    lockRef.current = rotationLocked;
  }, [localPaintMode, localEraseMode, rotationLocked]);

  // ============================================================
  // === Render =================================================
  // ============================================================
  return <div ref={mountRef} style={{ width: "100vw", height: "100vh" }} />;
});

// ============================================================
// === Generators (shared across pages) =======================
// ============================================================

export function toIN(valueInMM: number): number {
  return valueInMM / 25.4;
}

/** Shared low-level generator used by all modes */
function _generateRingsBase({
  rows,
  cols,
  ID_mm,
  WD_mm,
  OD_mm,
  centerSpacing,
  angleIn,
  angleOut,
  layout,
}: {
  rows: number;
  cols: number;
  ID_mm: number;
  WD_mm: number;
  OD_mm: number;
  centerSpacing?: number;
  angleIn?: number;
  angleOut?: number;
  layout?: any[];
}): any[] {
  if (!Number.isFinite(rows) || rows <= 0) rows = 1;
  if (!Number.isFinite(cols) || cols <= 0) cols = 1;

  const MAX_RINGS = 10000;
  if (rows * cols > MAX_RINGS) {
    console.warn(`‚ö†Ô∏è Requested ${rows * cols} rings ‚Äî limiting to ${MAX_RINGS}.`);
    const capped = Math.floor(Math.sqrt(MAX_RINGS));
    rows = capped;
    cols = capped;
  }

  if (!Number.isFinite(ID_mm) || ID_mm <= 0) ID_mm = 5;
  if (!Number.isFinite(WD_mm) || WD_mm <= 0) WD_mm = 1;
  if (!Number.isFinite(OD_mm) || OD_mm <= 0) OD_mm = ID_mm + 2 * WD_mm;

  let spacing = centerSpacing ?? 7.5;
  if (!Number.isFinite(spacing) || spacing <= 0 || spacing > 50) spacing = 7.5;

  const rings: any[] = [];

  for (let r = 0; r < rows; r++) {
    const tiltDeg = (r % 2 === 0 ? angleIn : angleOut) ?? 0;
    const tiltRad = THREE.MathUtils.degToRad(tiltDeg);

    for (let c = 0; c < cols; c++) {
      const jsonRing = layout?.find?.((el) => el.row === r && el.col === c) ?? {};

      const spacingVal = jsonRing.centerSpacing ?? spacing ?? 7.5;

      const x = Number.isFinite(jsonRing.x) ? jsonRing.x : c * spacingVal;
      const y = Number.isFinite(jsonRing.y)
        ? jsonRing.y
        : r * (spacingVal * Math.sqrt(3) / 2);
      const z = Number.isFinite(jsonRing.z) ? jsonRing.z : 0;

      const inner = Number.isFinite(jsonRing.innerDiameter)
        ? jsonRing.innerDiameter
        : ID_mm;
      const wire = Number.isFinite(jsonRing.wireDiameter)
        ? jsonRing.wireDiameter
        : WD_mm;

      rings.push({
        row: r,
        col: c,
        x,
        y,
        z,
        innerDiameter: inner,
        wireDiameter: wire,
        radius: (inner + wire) / 2,
        tiltRad,
        centerSpacing: spacingVal,
      });
    }
  }

  return rings;
}

// === Chart Mode =============================================
export function generateRingsChart({
  rows,
  cols,
  innerDiameter,
  wireDiameter,
  centerSpacing,
  angleIn = 25,
  angleOut = -25,
  layout,
}: {
  rows: number;
  cols: number;
  innerDiameter: string | number;
  wireDiameter: number;
  centerSpacing?: number;
  angleIn?: number;
  angleOut?: number;
  layout?: any[];
}) {
  const id_in = parseInchFractionToInches(innerDiameter);
  const ID_mm = inchesToMm(id_in);
  const WD_mm = wireDiameter;
  const OD_mm = ID_mm + 2 * WD_mm;

  const rings = _generateRingsBase({
    rows,
    cols,
    ID_mm,
    WD_mm,
    OD_mm,
    centerSpacing,
    angleIn,
    angleOut,
    layout,
  });

  rings.forEach((r) => {
    const wd = +(r.wireDiameter ?? WD_mm).toFixed(2);
    const id = +(r.innerDiameter ?? ID_mm).toFixed(2);
    const label = new SpriteText(`${wd}mm / ${id}mm`);
    label.color = "#CCCCCC";
    label.textHeight = 2.2;
    label.position.set(r.x, -r.y - (r.wireDiameter ?? WD_mm) * 4, r.z ?? 0);
    label.center.set(0.5, 1.2);
    (label.material as any).depthTest = false;
    (label.material as any).depthWrite = false;
    (r as any)._chartLabel = label;
  });

  return rings;
}

// === Designer Mode ==========================================
export function generateRingsDesigner({
  rows,
  cols,
  innerDiameter,
  wireDiameter,
  centerSpacing,
  angleIn = 25,
  angleOut = -25,
  layout,
}: {
  rows: number;
  cols: number;
  innerDiameter: number;
  wireDiameter: number;
  centerSpacing?: number;
  angleIn?: number;
  angleOut?: number;
  layout?: any[];
}) {
  const ID_mm = innerDiameter;
  const WD_mm = wireDiameter;
  const OD_mm = ID_mm + 2 * WD_mm;

  return _generateRingsBase({
    rows,
    cols,
    ID_mm,
    WD_mm,
    OD_mm,
    centerSpacing,
    angleIn,
    angleOut,
    layout,
  });
}

// === Tuner Mode =============================================
export function generateRingsTuner({
  rows,
  cols,
  innerDiameter,
  wireDiameter,
  centerSpacing,
  angleIn = 25,
  angleOut = -25,
  layout,
}: {
  rows: number;
  cols: number;
  innerDiameter: number;
  wireDiameter: number;
  centerSpacing?: number;
  angleIn?: number;
  angleOut?: number;
  layout?: any[];
}) {
  const ID_mm = innerDiameter;
  const WD_mm = wireDiameter;
  const OD_mm = ID_mm + 2 * WD_mm;
  const rings = _generateRingsBase({
    rows,
    cols,
    ID_mm,
    WD_mm,
    OD_mm,
    centerSpacing,
    angleIn,
    angleOut,
    layout,
  });

  rings.forEach((r) => {
    const label = new SpriteText(`Row:${r.row},Col:${r.col}`);
    label.color = "#00FFFF";
    label.textHeight = 2;
    label.position.set(r.x, -r.y - 2, 0);
    (r as any)._debugLabel = label;
  });
  return rings;
}

// === Backward Compatibility Alias ===========================
export const generateRings = generateRingsDesigner;
export default RingRenderer;
   