// src/App.tsx
import React, { useEffect, useMemo, useRef, useState } from "react";

/* ---------- Types ---------- */
interface Ring {
  row: number;
  col: number;
  x: number;     // world coords
  y: number;     // world coords
  radius: number; // world units
  color?: string;
}
type ColorMode = "solid" | "checker";
type Unit = "mm" | "in";

interface Params {
  rows: number;
  cols: number;
  innerDiameter: number; // mm
  wireDiameter: number;  // mm (used as lineWidth baseline)
  overlapX: number;      // 0..1
  overlapY: number;      // 0..1
  colorMode: ColorMode;
  ringColor: string;
  altColor: string;
  bgColor: string;
  supplier: string;
  ringSpec: string;
  unit: Unit;
}

/* ---------- Data ---------- */
const SUPPLIERS = [
  { id: "cmj", name: "Chainmail Joe" },
  { id: "trl", name: "The Ring Lord" },
];

// Simplified starter palettes. Replace with real supplier color sets later.
const PALETTES: Record<string, string[]> = {
  cmj: ["#c0c0c0", "#ffd700", "#ff0000", "#0000ff", "#008000", "#000000", "#8a2be2", "#ff69b4"],
  trl: ["#d4d4d4", "#ff69b4", "#ffa500", "#00ffff", "#800080", "#333333", "#00ff7f", "#1e90ff"],
};
// ---- Supplier color names (labels) ----
const SUPPLIER_COLOR_NAMES: Record<string, Record<string, string>> = {
  cmj: {
    "#C0C0C0": "Bright Aluminum",
    "#FFD700": "Gold",
    "#FF0000": "Red",
    "#4CBB17": "Kelly Green",
    "#556B2F": "OD Green",
    "#0000FF": "Blue",
    "#FF1493": "Cosmic Pink",
    "#8F00FF": "Violet",
    "#708090": "Stormy Gray",
    "#FFA500": "Orange",
    "#40E0D0": "Turquoise",
    "#000000": "Black",
  },
  trl: {
    "#1D1F2B": "Black Ice",
    "#D4D4D4": "Frost",
    "#A05056": "Dark Rose",
    "#BFFF00": "Lime",
    "#FFA500": "Orange",
    "#FFFF00": "Yellow",
    "#008000": "Green",
    "#800080": "Purple",
    "#0000FF": "Blue",
    "#C0C0C0": "Silver",
  },
};

function supplierColorName(supplier: string, hex: string): string {
  const key = hex.trim().toUpperCase();
  const map = SUPPLIER_COLOR_NAMES[supplier] || {};
  return map[key] || hex;
}
const RING_SPECS = [
  { label: '1/4" 16swg AR~4.0', inner: 6.35, wire: 1.6 },
  { label: '5/16" 16swg AR~5.0', inner: 7.94, wire: 1.6 },
  { label: '3/8" 16swg AR~6.2', inner: 9.53, wire: 1.6 },
  { label: '1/4" 18swg AR~4.4', inner: 6.35, wire: 1.2 },
  { label: '5/16" 18swg AR~6.1', inner: 7.94, wire: 1.2 },
];

const DEFAULTS: Params = {
  rows: 20,
  cols: 20,
  innerDiameter: 6.35,
  wireDiameter: 1.6,
  overlapX: 0.30,
  overlapY: 0.15,
  colorMode: "solid",
  ringColor: "#b8c2cc",
  altColor: "#94a3b8",
  bgColor: "#0b0f14",
  supplier: "cmj",
  ringSpec: '1/4" 16swg AR~4.0',
  unit: "mm",
};

/* ---------- Math helpers ---------- */
const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));

function pitches(p: Params) {
  const pitchX = p.innerDiameter * (1 - p.overlapX);
  const pitchY = (p.innerDiameter + p.wireDiameter) * (1 - p.overlapY);
  return { pitchX, pitchY };
}

function worldSize(p: Params) {
  const { pitchX, pitchY } = pitches(p);
  // Left/top at (0,0); last center + half diameter
  const width = (p.cols - 1) * pitchX + p.innerDiameter;
  const height = (p.rows - 1) * pitchY + p.innerDiameter;
  return { width, height };
}

function generateRings(p: Params): Ring[] {
  const { pitchX, pitchY } = pitches(p);
  const r = p.innerDiameter / 2;
  const rings: Ring[] = [];
  for (let row = 0; row < p.rows; row++) {
    for (let col = 0; col < p.cols; col++) {
      const x = col * pitchX + (row % 2) * (pitchX / 2);
      const y = row * pitchY;
      rings.push({ row, col, x, y, radius: r });
    }
  }
  return rings;
}

// why: preserve per-ring colors when grid changes
function syncRings(p: Params, prev: Ring[]): Ring[] {
  const base = generateRings(p);
  if (!prev.length) return base;
  const colorMap = new Map<string, string | undefined>();
  for (const r of prev) colorMap.set(`${r.row}:${r.col}`, r.color);
  return base.map((r) => ({ ...r, color: colorMap.get(`${r.row}:${r.col}`) }));
}

/* ---------- Component ---------- */
export default function App() {
  const [params, setParams] = useState<Params>(DEFAULTS);
  const [rings, setRings] = useState<Ring[]>([]);
  const [selectedRing, setSelectedRing] = useState<Ring | null>(null);

  // Paint/Eraser
  const [paintMode, setPaintMode] = useState(false);
  const [eraserMode, setEraserMode] = useState(false);
  const [isPainting, setIsPainting] = useState(false);
  const [customColor, setCustomColor] = useState("#ffffff");
  const [currentBrushColor, setCurrentBrushColor] = useState("#ffffff");

  // Viewport
  const [scale, setScale] = useState(1);         // 0.1 .. 10
  const [offset, setOffset] = useState({ x: 40, y: 40 }); // px
  const [isPanning, setIsPanning] = useState(false);
  const panStart = useRef<{ x: number; y: number } | null>(null);

  // Refs
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const wrapRef = useRef<HTMLDivElement>(null);

  // Ring list (paged to avoid DOM overload at 160k rings)
  const [page, setPage] = useState(0);
  const pageSize = 200;

  // Build/sync rings when grid or geometry changes
  useEffect(() => {
    setRings((prev) => syncRings(params, prev));
  }, [params.rows, params.cols, params.innerDiameter, params.wireDiameter, params.overlapX, params.overlapY]);

  // Canvas sizing (DPR-aware) + render
  const { worldW, worldH, pad } = useMemo(() => {
    const { width, height } = worldSize(params);
    const pad = Math.max(40, params.innerDiameter * 2);
    return { worldW: width, worldH: height, pad };
  }, [params]);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const dpr = window.devicePixelRatio || 1;
    const cssW = Math.ceil((worldW + pad * 2));
    const cssH = Math.ceil((worldH + pad * 2));
    canvas.width = Math.max(1, Math.floor(cssW * dpr));
    canvas.height = Math.max(1, Math.floor(cssH * dpr));
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // DPR scale
    draw(ctx, cssW, cssH);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [params, rings, selectedRing, scale, offset, worldW, worldH, pad]);

  const palette = PALETTES[params.supplier] ?? [];

  function ringColorFallback(r: Ring): string {
    if (r.color) return r.color;
    if (params.colorMode === "checker" && (r.row + r.col) % 2 === 1) return params.altColor;
    return params.ringColor;
  }
  function computeColorUsage(rings: Ring[], params: Params) {
    const counts: Record<string, number> = {};
    for (const r of rings) {
      const hex = ringColorFallback(r).toUpperCase();
      counts[hex] = (counts[hex] || 0) + 1;
    }
    return counts;
  }
  function renderedColorForRing(p: Params, r: Ring): string {
  	if (r.color) return r.color;
  	if (p.colorMode === "checker" && (r.row + r.col) % 2 === 1) return p.altColor;
  	return p.ringColor;
  }
  function draw(ctx: CanvasRenderingContext2D, cssW: number, cssH: number) {
    ctx.save();
    ctx.clearRect(0, 0, cssW, cssH);

    // background
    ctx.fillStyle = params.bgColor;
    ctx.fillRect(0, 0, cssW, cssH);

    // world transform (pan+zoom) anchored after padding
    ctx.translate(offset.x + pad, offset.y + pad);
    ctx.scale(scale, scale);

    // sheet area (for visual bounds)
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(-params.innerDiameter, -params.innerDiameter, worldW + params.innerDiameter * 2, worldH + params.innerDiameter * 2);

    // rings
    for (const r of rings) {
      ctx.strokeStyle = ringColorFallback(r);
      ctx.lineWidth = params.wireDiameter / scale; // why: keep stroke visually consistent across zoom
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
      ctx.stroke();
    }

    // selection
    if (selectedRing) {
      const s = selectedRing;
      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2 / scale;
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.radius + 3 / scale, 0, Math.PI * 2);
      ctx.stroke();
    }

    ctx.restore();
  }
  const colorUsage = computeColorUsage(rings, params);
  /* ---------- Coordinate transforms ---------- */
  function screenToWorld(clientX: number, clientY: number) {
    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const sx = clientX - rect.left - pad;
    const sy = clientY - rect.top - pad;
    return { x: (sx - offset.x) / scale, y: (sy - offset.y) / scale };
  }
  function worldToScreen(wx: number, wy: number) {
    const x = (wx * scale) + offset.x + pad;
    const y = (wy * scale) + offset.y + pad;
    return { x, y };
  }

  /* ---------- Interactions ---------- */
  // Zoom (cursor-centered)
  function onWheel(e: React.WheelEvent) {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.1 : 0.9;
    const newScale = clamp(scale * factor, 0.1, 20);

    const canvas = canvasRef.current!;
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left - pad;
    const my = e.clientY - rect.top - pad;

    const wx = (mx - offset.x) / scale;
    const wy = (my - offset.y) / scale;

    const nx = wx * newScale + offset.x;
    const ny = wy * newScale + offset.y;

    // keep cursor-anchored
    setOffset({ x: offset.x + (mx - nx), y: offset.y + (my - ny) });
    setScale(newScale);
  }

  function onMouseDown(e: React.MouseEvent<HTMLCanvasElement>) {
    if (paintMode || eraserMode) {
      setIsPainting(true);
      const { x, y } = screenToWorld(e.clientX, e.clientY);
      paintAt(x, y);
      return;
    }
    setIsPanning(true);
    panStart.current = { x: e.clientX - offset.x, y: e.clientY - offset.y };
  }
  function onMouseMove(e: React.MouseEvent<HTMLCanvasElement>) {
    if (isPainting && (paintMode || eraserMode)) {
      const { x, y } = screenToWorld(e.clientX, e.clientY);
      paintAt(x, y);
      return;
    }
    if (!isPanning || !panStart.current) return;
    setOffset({ x: e.clientX - panStart.current.x, y: e.clientY - panStart.current.y });
  }
  function onMouseUp() {
    setIsPainting(false);
    setIsPanning(false);
    panStart.current = null;
  }
  function onClick(e: React.MouseEvent<HTMLCanvasElement>) {
    if (paintMode || eraserMode) return;
    const { x, y } = screenToWorld(e.clientX, e.clientY);
    const hit = hitTest(x, y);
    setSelectedRing(hit);
  }

  function hitTest(wx: number, wy: number): Ring | null {
    // local neighborhood search for speed
    // (simple linear scan is OK up to tens of thousands; for 160k it’s still acceptable interactively)
    for (const r of rings) {
      const dx = wx - r.x, dy = wy - r.y;
      if (dx * dx + dy * dy <= (r.radius + 3) * (r.radius + 3)) return r;
    }
    return null;
  }

  function paintAt(wx: number, wy: number) {
    const color = eraserMode ? undefined : currentBrushColor;
    setRings((prev) =>
      prev.map((r) => {
        const dx = wx - r.x, dy = wy - r.y;
        if (dx * dx + dy * dy <= (r.radius + 3) * (r.radius + 3)) {
          return { ...r, color };
        }
        return r;
      })
    );
  }

  function assignColorToSelected(color: string) {
    if (!selectedRing) return;
    setRings((prev) =>
      prev.map((r) =>
        r.row === selectedRing.row && r.col === selectedRing.col ? { ...r, color } : r
      )
    );
  }

  function assignColorToAll(color: string) {
    setRings((prev) => prev.map((r) => ({ ...r, color })));
  }
  function clearAllColors() {
    setRings((prev) => prev.map((r) => ({ ...r, color: undefined })));
  }

  // View helpers
  function fitToView() {
    const wrap = wrapRef.current!;
    const vw = wrap.clientWidth - 16, vh = wrap.clientHeight - 16;
    const s = clamp(Math.min(vw / (worldW + pad * 2), vh / (worldH + pad * 2)), 0.05, 20);
    setScale(s);
    setOffset({ x: (vw - (worldW + pad * 2) * s) / 2 + (pad * (1 - s)), y: (vh - (worldH + pad * 2) * s) / 2 + (pad * (1 - s)) });
  }
  function centerView() {
    const wrap = wrapRef.current!;
    const vw = wrap.clientWidth, vh = wrap.clientHeight;
    setOffset({ x: vw / 2 - (worldW / 2) * scale - pad, y: vh / 2 - (worldH / 2) * scale - pad });
  }
  function oneToOne() {
    setScale(1);
    centerView();
  }
  function goToRing(row: number, col: number, targetScale?: number) {
    const { pitchX, pitchY } = pitches(params);
    const rx = col * pitchX + (row % 2) * (pitchX / 2);
    const ry = row * pitchY;
    const wrap = wrapRef.current!;
    const vw = wrap.clientWidth, vh = wrap.clientHeight;
    const s = clamp(targetScale ?? clamp(scale, 0.2, 6), 0.05, 20);
    setScale(s);
    setOffset({ x: vw / 2 - rx * s - pad, y: vh / 2 - ry * s - pad });
    const ring = rings.find((r) => r.row === row && r.col === col);
    setSelectedRing(ring ?? null);
  }
  const colorCounts = useMemo(() => {
  	const counts: Record<string, number> = {};
  	for (const r of rings) {
      const hex = renderedColorForRing(params, r);
      counts[hex] = (counts[hex] || 0) + 1;
    }
    return counts;
  }, [rings, params.ringColor, params.altColor, params.colorMode]);
  // Ring list pagination window
  const total = rings.length;
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  const safePage = clamp(page, 0, totalPages - 1);
  const slice = rings.slice(safePage * pageSize, safePage * pageSize + pageSize);

  return (
    <div className="h-screen w-screen bg-slate-900 text-slate-100 grid grid-cols-[320px,1fr,280px] grid-rows-[auto,1fr]">
      {/* Top bar */}
      <div className="col-span-3 flex items-center justify-between px-4 py-2 border-b border-slate-800 bg-slate-950/70 backdrop-blur">
        <div className="text-lg font-semibold">Chainmaille Designer • 4-in-1</div>
        <div className="flex items-center gap-2 text-xs">
          <button onClick={fitToView} className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700">Fit</button>
          <button onClick={centerView} className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700">Center</button>
          <button onClick={oneToOne} className="px-2 py-1 rounded bg-slate-800 hover:bg-slate-700">1:1</button>
          <div className="px-2 py-1 rounded border border-slate-700 ml-2">Zoom: {scale.toFixed(2)}×</div>
        </div>
      </div>

      {/* Left panel */}
      <div className="row-span-1 border-r border-slate-800 p-3 overflow-auto">
        <div className="text-xs uppercase tracking-wide text-slate-400 mb-2">Sheet</div>
        <div className="space-y-3">
          <label className="block text-sm">Rows: {params.rows}</label>
          <input type="range" min={5} max={400} value={params.rows} onChange={(e) => setParams({ ...params, rows: parseInt(e.target.value) })} className="w-full" />
          <label className="block text-sm">Columns: {params.cols}</label>
          <input type="range" min={5} max={400} value={params.cols} onChange={(e) => setParams({ ...params, cols: parseInt(e.target.value) })} className="w-full" />

          <div className="text-xs uppercase tracking-wide text-slate-400 mt-4">Geometry</div>
          <label className="block text-sm">Inner Ø (mm): {params.innerDiameter.toFixed(2)}</label>
          <input type="range" min={2} max={20} step={0.1} value={params.innerDiameter} onChange={(e) => setParams({ ...params, innerDiameter: parseFloat(e.target.value) })} className="w-full" />
          <label className="block text-sm">Wire Ø (mm): {params.wireDiameter.toFixed(2)}</label>
          <input type="range" min={0.6} max={4} step={0.1} value={params.wireDiameter} onChange={(e) => setParams({ ...params, wireDiameter: parseFloat(e.target.value) })} className="w-full" />
          <label className="block text-sm">Overlap X: {params.overlapX.toFixed(2)}</label>
          <input type="range" min={0} max={0.8} step={0.01} value={params.overlapX} onChange={(e) => setParams({ ...params, overlapX: parseFloat(e.target.value) })} className="w-full" />
          <label className="block text-sm">Overlap Y: {params.overlapY.toFixed(2)}</label>
          <input type="range" min={0} max={0.8} step={0.01} value={params.overlapY} onChange={(e) => setParams({ ...params, overlapY: parseFloat(e.target.value) })} className="w-full" />

          <div className="text-xs uppercase tracking-wide text-slate-400 mt-4">Supplier</div>
          <label className="block text-sm">Supplier</label>
          <select value={params.supplier} onChange={(e) => setParams({ ...params, supplier: e.target.value })} className="w-full rounded bg-slate-800 p-2">
            {SUPPLIERS.map((s) => <option key={s.id} value={s.id}>{s.name}</option>)}
          </select>

          <label className="block text-sm mt-2">Ring Size</label>
          <select
            value={params.ringSpec}
            onChange={(e) => {
              const spec = RING_SPECS.find((r) => r.label === e.target.value);
              if (spec) setParams({ ...params, ringSpec: spec.label, innerDiameter: spec.inner, wireDiameter: spec.wire });
            }}
            className="w-full rounded bg-slate-800 p-2"
          >
            {RING_SPECS.map((r) => <option key={r.label} value={r.label}>{r.label}</option>)}
          </select>

          <div className="text-xs uppercase tracking-wide text-slate-400 mt-4">Color Mode</div>
          <select
            value={params.colorMode}
            onChange={(e) => setParams({ ...params, colorMode: e.target.value as ColorMode })}
            className="w-full rounded bg-slate-800 p-2"
          >
            <option value="solid">Solid</option>
            <option value="checker">Checker</option>
          </select>

          <div className="grid grid-cols-2 gap-2 mt-2">
            <div>
              <div className="text-xs text-slate-300">Primary</div>
              <input type="color" value={params.ringColor} onChange={(e) => setParams({ ...params, ringColor: e.target.value })} className="w-full h-8" />
            </div>
            <div>
              <div className="text-xs text-slate-300">Alternate</div>
              <input type="color" value={params.altColor} onChange={(e) => setParams({ ...params, altColor: e.target.value })} className="w-full h-8" />
            </div>
            <div className="col-span-2">
              <div className="text-xs text-slate-300">Background</div>
              <input type="color" value={params.bgColor} onChange={(e) => setParams({ ...params, bgColor: e.target.value })} className="w-full h-8" />
            </div>
          </div>
        </div>
      </div>

      {/* Canvas area (scrollable wrapper) */}
      <div ref={wrapRef} className="row-span-1 bg-slate-800 overflow-auto relative">
        <canvas
          ref={canvasRef}
          onWheel={onWheel}
          onMouseDown={onMouseDown}
          onMouseMove={onMouseMove}
          onMouseUp={onMouseUp}
          onClick={onClick}
          className={`${(paintMode || eraserMode) ? "cursor-crosshair" : (isPanning ? "cursor-grabbing" : "cursor-grab")}`}
          style={{ width: worldW + pad * 2, height: worldH + pad * 2 }}
        />
        <div className="absolute bottom-2 left-2 text-[10px] text-slate-300 bg-slate-900/60 border border-slate-700 rounded px-2 py-1">
          Wheel: zoom • Drag: pan • Paint/Eraser: toggle on right
        </div>
      </div>
	  <div className="text-xs uppercase tracking-wide text-slate-400 mb-2 mt-4">
        Color Usage
      </div>
      <div className="space-y-1 mb-4 text-xs">
        {Object.entries(colorUsage).map(([hex, count]) => (
          <div key={hex} className="flex items-center justify-between bg-slate-800 rounded px-2 py-1">
            <div className="flex items-center gap-2">
              <span className="inline-block h-3 w-3 rounded-full" style={{ backgroundColor: hex }} />
              <span>
                {supplierColorName(params.supplier, hex)} ({hex})
              </span>
            </div>
            <span>{count}</span>
          </div>
        ))}
       </div>
      {/* Right panel (palette, actions, ring list) */}
      <div className="row-span-1 border-l border-slate-800 p-3 overflow-auto">
        <div className="text-xs uppercase tracking-wide text-slate-400 mb-2">Palette</div>
        <div className="grid grid-cols-4 gap-2 mb-3">
          {palette.map((c) => (
            <button
              key={c}
              onClick={() => {
                setCurrentBrushColor(c);
                if (!paintMode && !eraserMode) assignColorToSelected(c);
              }}
              title={c}
              style={{ backgroundColor: c }}
              className="h-7 w-7 rounded-full border border-white/70"
            />
          ))}
        </div>
        <div className="mb-3">
          <input type="color" value={customColor} onChange={(e) => setCustomColor(e.target.value)} className="w-full h-10 mb-2" />
          <div className="grid grid-cols-2 gap-2">
            <button
              onClick={() => { setCurrentBrushColor(customColor); if (!paintMode && !eraserMode) assignColorToSelected(customColor); }}
              className="px-2 py-1 bg-slate-700 rounded"
            >Apply Custom</button>
            <button onClick={() => assignColorToAll(currentBrushColor)} className="px-2 py-1 bg-slate-600 rounded">Apply to All</button>
            <button onClick={clearAllColors} className="col-span-2 px-2 py-1 bg-rose-600 rounded">Clear All</button>
          </div>
        </div>

        <div className="text-xs uppercase tracking-wide text-slate-400 mb-2">Tools</div>
        <div className="grid grid-cols-2 gap-2 mb-3">
          <button
            onClick={() => { setPaintMode((v) => !v); if (eraserMode) setEraserMode(false); }}
            className={`px-2 py-1 rounded ${paintMode ? "bg-green-700" : "bg-slate-600"}`}
          >{paintMode ? "Paint: ON" : "Paint: OFF"}</button>
          <button
            onClick={() => { setEraserMode((v) => !v); if (paintMode) setPaintMode(false); }}
            className={`px-2 py-1 rounded ${eraserMode ? "bg-red-700" : "bg-slate-600"}`}
          >{eraserMode ? "Eraser: ON" : "Eraser: OFF"}</button>
        </div>

        <div className="text-xs uppercase tracking-wide text-slate-400 mb-2">Go to ring</div>
        <GotoRingForm
          rows={params.rows}
          cols={params.cols}
          onGo={(r, c) => goToRing(r, c, 4)} // why: default zoom in when jumping
        />

        <div className="text-xs uppercase tracking-wide text-slate-400 mt-4 mb-2">Ring List (page {safePage + 1}/{totalPages})</div>
        <div className="flex items-center gap-2 mb-2">
          <button onClick={() => setPage((p) => clamp(p - 1, 0, totalPages - 1))} className="px-2 py-1 bg-slate-700 rounded">Prev</button>
          <button onClick={() => setPage((p) => clamp(p + 1, 0, totalPages - 1))} className="px-2 py-1 bg-slate-700 rounded">Next</button>
        </div>
        <div className="h-64 overflow-auto text-xs space-y-1">
          {slice.map((r, i) => (
            <div
              key={`${r.row}:${r.col}:${i}`}
              onClick={() => setSelectedRing(r)}
              className={`p-1 rounded cursor-pointer flex items-center justify-between ${selectedRing && selectedRing.row === r.row && selectedRing.col === r.col ? "bg-slate-600" : "bg-slate-800"}`}
            >
              <span>({r.row},{r.col})</span>
              <span className="inline-block h-3 w-3 rounded-full" style={{ backgroundColor: ringColorFallback(r) }} />
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

/* ---------- Small UI helper ---------- */
function GotoRingForm({ rows, cols, onGo }: { rows: number; cols: number; onGo: (row: number, col: number) => void; }) {
  const [row, setRow] = useState(0);
  const [col, setCol] = useState(0);
  return (
    <div className="flex gap-2 mb-2">
      <input type="number" min={0} max={rows - 1} value={row} onChange={(e) => setRow(parseInt(e.target.value || "0"))} className="w-20 bg-slate-800 border border-slate-700 rounded p-1 text-xs" placeholder="row" />
      <input type="number" min={0} max={cols - 1} value={col} onChange={(e) => setCol(parseInt(e.target.value || "0"))} className="w-20 bg-slate-800 border border-slate-700 rounded p-1 text-xs" placeholder="col" />
      <button onClick={() => onGo(clamp(row, 0, rows - 1), clamp(col, 0, cols - 1))} className="px-2 py-1 bg-slate-700 rounded text-xs">Go</button>
    </div>
  );
}